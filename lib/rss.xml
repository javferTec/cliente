<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Desarrollo Web en Entorno Cliente]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>Desarrollo Web en Entorno Cliente</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 26 Nov 2024 11:55:55 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 26 Nov 2024 11:55:54 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[ARQUITECTURA Y TECNOLOGÍAS. PROGRAMACIÓN EN LA WEB]]></title><description><![CDATA[ 
 <br><br><br>JavaScript se creó inicialmente para "dar vida a las páginas web".<br>Los programas en este lenguaje se llaman scripts. Se pueden escribir directamente en el HTML de una página web y ejecutarse automáticamente a medida que se carga la página. Los scripts se proporcionan y ejecutan como texto sin formato. No necesitan preparación especial o compilación para correr.<br><br>JavaScript en el navegador puede hacer todo lo relacionado con la manipulación de la página web, la interacción con el usuario y el servidor web. Por ejemplo, JavaScript en el navegador puede: <br>
<br>
Agregar nuevo HTML a la página, cambiar el contenido existente, modificar estilos a través del DOM.

<br>
Reaccionar a las acciones del usuario a través de los eventos, (clics del mouse, movimientos del puntero, pulsaciones de teclas…).

<br>
Enviar solicitudes a través de la red a servidores remotos, las llamadas tecnologías AJAX.

<br>
Obtener y establecer cookies, Almacenar los datos en el lado del cliente (Local Storage "almacenamiento local").

<br><br>
<br>Integración completa con HTML / CSS.
<br>Las cosas simples se hacen simplemente.
<br>Soporte por todos los principales navegadores y habilitado por defecto.
]]></description><link>0-introduccion\arquitecturas-y-tecnologías-programación-web-en-cliente.html</link><guid isPermaLink="false">0- Introduccion/Arquitecturas y tecnologías  - programación Web en cliente.md</guid><pubDate>Sun, 03 Nov 2024 12:14:44 GMT</pubDate></item><item><title><![CDATA[SINTAXIS DEL LENGUAJE]]></title><description><![CDATA[ 
 <br><br><br>Hay dos formas de hacer referencia a código JavaScript:<br>
<br>Código en el propio archivo HTML:
<br>&lt;script&gt;

alert("Hola Mundo");

&lt;/script&gt;
<br>
<br>Código en un fichero externo:
<br>&lt;script src="./js/index.js"&gt;&lt;/script&gt;
&lt;!-- La etiqueta type="text/javascript" no es necesaria --&gt;
<br>Note
La etiqueta script debe incluirse antes del final del cierre de la etiqueta body del HTML.
<br><br>Con los módulos los ficheros de JS podrán exportar e importar código y/o datos de otros archivos de JS. Un módulo puede exportar y a la vez importar. Esto implica numerosos beneficios:<br>
<br>Modularidad: Divide el código en partes reutilizables, mejorando la organización y el mantenimiento.
<br>Reutilización: Permite importar y usar código de otros módulos, evitando la duplicación de código.
<br>Encapsulación: Oculta la implementación interna de un módulo, exponiendo solo la interfaz pública.
<br>Carga asíncrona: Carga los módulos solo cuando se necesitan, mejorando el rendimiento.
<br><br>1- Exportar un elemento:<br>export const articulos = [
	{id:1, nombre:"articulo1"},
	{id:2, nombre:"articulo2"},
	{id:3, nombre:"articulo3"}
];
<br>2- Importar un elemento:<br>import {articulos} from "./datos.js"
<br>3- Uso en el HTML:<br>&lt;script src="./js/main.js" type="module"&gt;&lt;/script&gt;
&lt;!-- Hay que indicar que es de tipo módulo --&gt;
<br><br>A veces al importar un módulo se crea un ámbito que el HTML no puede alcanzar.<br>La solución más efectiva es a través del DOM (Document Object Element) <br>Ejemplo:<br>
<br>HTML:
<br>&lt;button id="btn"&gt;Bienvenida DOM&lt;/button&gt;
<br>
<br>JS:
<br>document.getElementById("btn").addEventListener("click", verMensaje)
<br><br>./CarpetaProyecto<br>
/assets -&gt; contiene las imágenes, vídeos y otros ficheros.<br>
/css -&gt; contiene los estilos CSS.<br>
/js -&gt; contiene los ficheros JS.<br>
/node_modules -&gt; contiene los módulos node (npm)<br>
index.html -&gt; página inicial de HTML.<br><br>var persona = "javi"; // variable de alcance global
let persona = "javi"; // variable de alcance en bloque
const persona = "javi"; // variable definida como constante, tras sun inicialización no se puede modificar
<br><br>JavaScript es un lenguaje de tipado dinámico, lo que significa que no es necesario especificar el tipo de dato de una variable al declararla. El tipo de dato se asigna automáticamente en función del valor inicial.<br>
<br>
Tipos de datos primitivos: son los más básicos y representan tipos de datos simples.

<br>Números: valores numéricos o decimales.
<br>Cadenas de texto: secuencia de carácteres.
<br>Booleanos: true o false.
<br>Null: ausencia de valor.
<br>Undefined: valor no definido.
<br>Symbol: valores únicos e inmutables.


<br>
Tipos de datos compuestos: estructuras que almacenan colecciones de datos:

<br>Objetos: estructuras de datos que contienen propiedades y métodos.
<br>Arrays: representan listas de valores de cualquier tipo.


<br>
El operador TypeOf: determina el tipo de dato de una variable. Devuelve una cadena que indica el tipo de dato. 

<br>"string": Para cadenas de texto.
<br>"number": Para números.
<br>"boolean": Para valores booleanos (true o false).
<br>"object": Para objetos, arrays y funciones.
<br>"undefined": Para variables no declaradas o valores no inicializados.
<br>"symbol": Para valores de tipo Symbol.
<br>"function": Para funciones.


<br>Tip
typeof no distingue entre diferentes tipos de objetos, como arrays o funciones. Ambos se consideran como tipo "object". Si necesitaramos distinguir entre tipos de objetos específicos, podemos utilizar instanceof.
<br><br>
<br>Conversiones implícitas (corrección de tipos): La conversión implícita ocurre automáticamente cuando JavaScript intenta realizar una operación con valores de diferentes tipos de datos. En estos casos, JavaScript convierte los valores al tipo de dato que sea necesario para la operación. 
<br>let numero = 10; 
let texto = "5"; 

let suma = numero + texto; // suma se convierte en "105" (cadena) console.log(suma); // Imprime: 105
<br>
<br>Conversiones explícitas (casting): La conversión explícita se realiza utilizando funciones específicas para convertir un valor de un tipo de dato a otro. Se utiliza cuando se desea un control preciso sobre el tipo de dato resultante.
<br>
public class stringToNumber {
	let texto = "10";
	let numero = Number(texto); // numero se convierte en 10 (número)
	console.log(numero); // Imprime: 10
}

public class numberToString {
	let numero = 20;
	let texto = String(numero); // texto se convierte en "20" (cadena)
	console.log(texto); // Imprime: 20
}

public class convertToBoolean { // función Boolean()
// valores truthy -&gt; números excepto 0, cadenas de texto excepto "", tru, objetos 
	let valor1 = 10; // truthy

// valores falsy -&gt; número 0, cadena vacía "", flase, null, undefined
	let valor2 = ""; // falsy

	let booleano1 = Boolean(valor1); // booleano1 se convierte en true
	let booleano2 = Boolean(valor2); // booleano2 se convierte en false
	console.log(booleano1, booleano2); // Imprime: true false
}
<br><br>
<br>
Operadores aritméticos:

<br>+: Suma
<br>-: Resta
<br>*: Multiplicación
<br>/: División
<br>%: Resto división
<br>++: Incremento
<br>--: Decremento


<br>
Operadores relacionales:

<br>==: Igualdad
<br>!=: Desigualdad
<br>&lt;: Menor que
<br>&lt;=: Menor o igual que
<br>&gt;: Mayor que
<br>&gt;=: Mayor o igual que


<br>
Operadores lógicos:

<br>&amp;&amp;: Conjunción (AND)
<br>||: Disyunción (OR)
<br>!: Negación (NOT)


<br>
Operadores de asignación:

<br>=: Asignación simple
<br>+=: Asignación por suma
<br>-=: Asignación por resta
<br>*=: Asignación por multiplicación
<br>/=: Asignación por división
<br>%=: Asignación por resto


<br>
Operadores de tipo:

<br>typeof: Devuelve el tipo de dato de un valor
<br>instanceof: Comprueba si un objeto es una instancia de un tipo específico


<br>
Operadores de coma (,):

<br>Separa expresiones en una instrucción
<br>Utilizado en bucles for como for (let i = 0, j = 10; i &lt; 10; i++, j--) { ... }


<br>
Operador condicional ternario (? :):

<br>Es una forma abreviada de una instrucción if-else


<br>
Operadores bit a bit:

<br>&amp;: AND bit a bit
<br>|: OR bit a bit
<br>^: XOR bit a bit
<br>&lt;&lt;: Desplazamiento de bits a la izquierda
<br>&gt;&gt;: Desplazamiento de bits a la derecha
<br>~: Negación bit a bit


<br><br>
<br>Sentencia if-else:
<br>if (condicion) {
 // Código a ejecutar si la condición es verdadera
} else {
 // Código a ejecutar si la condición es falsa
}
<br>
<br>Sentencia switch:
<br>switch (expresion) {
	case valor1:
		 // Código a ejecutar si la expresión es igual a valor1
		 break;
	 case valor2:
		 // Código a ejecutar si la expresión es igual a valor2
		 break;
	 default:
		 // Código a ejecutar si la expresión no coincide con ningún caso
}

<br>
<br>Operador condicional ternario (? :) :
<br>let resultado = (condicion) ? valor_verdadero : valor_falso;
// valor_verdadero = si se cumple
// valor_falso = si no se cumple
<br><br>
<br>Bucle for: Se utiliza para ejecutar un bloque de código un número específico de veces. Se basa en tres partes: una inicialización, una condición y una actualización.
<br>for (let i = 0; i &lt; 10; i++) {
 // Código a ejecutar 10 veces
}
<br>
<br>Bucle for-in: Se utiliza para recorrer las propiedades de un objeto y ejecutar un bloque de código para cada propiedad.
<br>let persona = { nombre: "Juan", edad: 30, profesion: "Desarrollador" };

for (let propiedad in persona) {
 console.log(`${propiedad}: ${persona[propiedad]}`);
}
<br>
<br>Bucle for-of: Se utiliza para recorrer los valores de un iterable (como un array o una cadena de texto) y ejecutar un bloque de código para cada valor
<br>let numeros = [10, 20, 30];

for (let numero of numeros) {
 console.log(numero);
}
<br>
<br>Bucle while: Se utiliza para ejecutar un bloque de código mientras se cumpla una condición específica. Se evalúa la condición antes de cada iteración del bucle.
<br>let i = 0;

while (i &lt; 10) {
 // Código a ejecutar mientras i sea menor que 10
 i++;
}

<br>
<br>Bucle do-while: El bucle do-while es similar al bucle while, pero la diferencia es que el bloque de código se ejecuta al menos una vez, incluso si la condición es falsa al principio.
<br>let i = 0;

do {
 // Código a ejecutar al menos una vez
 i++;
} while (i &lt; 10);
<br><br>En programación funcional y usando funciones de flecha en JavaScript, en lugar de bucles explícitos, solemos usar métodos de arrays e iteradores, como map, forEach, filter, reduce, etc., que permiten manipular datos de una manera más declarativa. A continuación, se muestran ejemplos de cómo implementar los diferentes tipos de bucles en un estilo funcional en JavaScript:<br><br>En lugar de usar un bucle for para ejecutar un bloque de código un número específico de veces, podemos usar el método Array.from para crear un array de cierto tamaño y luego aplicar un método funcional como forEach.<br>Array.from({ length: 10 }).forEach((_, i) =&gt; {
  // Código a ejecutar 10 veces
  console.log(`Iteración ${i + 1}`);
});
<br><br>Para iterar sobre las propiedades de un objeto, podemos usar Object.keys, Object.values o Object.entries con forEach. Esto nos permite recorrer cada propiedad o valor sin un bucle explícito for-in.<br>const persona = { nombre: "Juan", edad: 30, profesion: "Desarrollador" };

Object.entries(persona).forEach(([propiedad, valor]) =&gt; {
  console.log(`${propiedad}: ${valor}`);
});
<br><br>Si necesitamos recorrer los valores de un iterable, podemos usar forEach o map en caso de que queramos transformar los valores del array.<br>const numeros = [10, 20, 30];

numeros.forEach(numero =&gt; console.log(numero));
<br><br>Los bucles while no tienen una correspondencia directa en programación funcional, pero si queremos ejecutar un bloque mientras se cumpla una condición, podemos simularlo usando recursión. Sin embargo, aquí mostramos un ejemplo de cómo podría hacerse:<br>const repetirHasta = (condicion, accion, i = 0) =&gt; {
  if (!condicion(i)) return;
  accion(i);
  repetirHasta(condicion, accion, i + 1);
};

// Ejemplo de uso:
repetirHasta(i =&gt; i &lt; 10, i =&gt; console.log(`Iteración ${i + 1}`));
<br><br>Para el bucle do-while, podemos modificar la función anterior para ejecutar la acción al menos una vez antes de verificar la condición, como en el siguiente ejemplo:<br>const repetirAlMenosUnaVez = (condicion, accion, i = 0) =&gt; {
  accion(i);
  if (!condicion(i)) return;
  repetirAlMenosUnaVez(condicion, accion, i + 1);
};

// Ejemplo de uso:
repetirAlMenosUnaVez(i =&gt; i &lt; 10, i =&gt; console.log(`Iteración ${i + 1}`));
]]></description><link>1-sintaxis\sintaxis-del-lenguaje.html</link><guid isPermaLink="false">1- Sintaxis/Sintaxis del lenguaje.md</guid><pubDate>Sun, 03 Nov 2024 16:31:25 GMT</pubDate></item><item><title><![CDATA[OBJETOS PREDEFINIDOS]]></title><description><![CDATA[ 
 <br><br>Los objetos predefinidos en JavaScript son objetos que ya están disponibles en el lenguaje y no necesitan ser creados por el usuario. Estos objetos proporcionan funcionalidades básicas y comunes que son esenciales para el desarrollo web y otras aplicaciones JavaScript. Algunos de los objetos predefinidos más importantes son:<br>
<br>
Objeto Window

<br>Representa la ventana del navegador.
<br>Permite acceder a propiedades y métodos como la URL, historial, tamaño de la ventana, etc.


<br>
Objeto Document

<br>Representa el documento HTML de la página.
<br>Facilita el acceso y manipulación de elementos y atributos del DOM (Document Object Model).


<br>
Objeto String

<br>Representa cadenas de texto.
<br>Incluye métodos para manipular texto: concatenar, dividir, buscar, reemplazar, y convertir entre mayúsculas/minúsculas.


<br>
Objeto Date

<br>Representa fechas y horas.
<br>Ofrece métodos para obtener y configurar datos de fecha como año, mes, día, hora, minutos y segundos.


<br>
Objeto Math

<br>Proporciona constantes y funciones matemáticas: PI, E, sen(), cos(), sqrt(), abs(), pow(), etc.


<br>
Objeto Array

<br>Representa listas ordenadas de valores.
<br>Métodos para manipular arrays: agregar, eliminar, buscar, insertar, y ordenar elementos.


<br>
Objeto Object

<br>Objeto base para todos los demás objetos en JavaScript.
<br>Métodos y propiedades para crear y gestionar objetos.


<br>
Objeto Error

<br>Representa errores en JavaScript.
<br>Proporciona propiedades para acceder al mensaje de error, nombre del archivo, y número de línea.


<br>
Objeto JSON

<br>Facilita la interpretación y generación de JSON (JavaScript Object Notation), un formato de datos ligero.


<br>
Objeto XMLHttpRequest

<br>
<br>Permite realizar solicitudes HTTP y obtener datos de servidores web.
<br><br>El objeto window en JavaScript es un objeto global que representa la ventana del navegador y proporciona acceso a sus propiedades y métodos. Es uno de los objetos más importantes en JavaScript y se utiliza para interactuar con la ventana del navegador, obtener información sobre la página web actual, manipular elementos HTML y controlar el comportamiento del navegador.<br><br>// 1. location: Proporciona información sobre la URL actual de la página web y permite redirigir a otras páginas.
console.log(window.location.href); // Imprime la URL actual
window.location.href = "https://www.example.com"; // Redirige a otra página

// 2. document: Representa el documento HTML de la página web, proporcionando acceso a sus elementos y métodos (DOM - Document Object Model).
let titulo = document.getElementById("tituloPagina");
titulo.textContent = "Nuevo título de la página"; // Cambia el texto del título

// 3. history: Proporciona acceso al historial del navegador, permitiendo navegar entre las páginas visitadas.
window.history.back(); // Navega a la página anterior
window.history.go(2);  // Navega dos páginas hacia atrás

// 4. screen: Proporciona información sobre las dimensiones de la pantalla, como la resolución.
let anchoPantalla = window.screen.width;
console.log(`Ancho de la pantalla: ${anchoPantalla} pixeles`); // Imprime el ancho de pantalla

// 5. navigator: Proporciona información sobre el navegador utilizado, como el nombre, la versión y el sistema operativo.
let navegador = window.navigator.userAgent;
console.log(`Navegador: ${navegador}`); // Imprime la información del navegador
<br><br>// 1. alert(): Muestra un cuadro de diálogo emergente con un mensaje y un botón de "Aceptar".
window.alert("¡Hola, mundo!"); // Muestra una alerta al usuario

// 2. prompt(): Muestra un cuadro de diálogo emergente para obtener información del usuario.
let nombre = window.prompt("Dime un nombre:");
console.log("Nombre:", nombre); // Imprime el nombre introducido o `null` si se canceló

// 3. confirm(): Muestra un cuadro de diálogo emergente para confirmar una acción, con "Aceptar" y "Cancelar".
let confirmar = window.confirm("¿Desea continuar?");
if (confirmar) {
	console.log("Usuario confirmó la acción");
} else {
	console.log("Usuario canceló la acción");
}

// 4. open(): Abre una nueva ventana del navegador con la URL especificada.
window.open("https://www.example.com", "_blank"); // Abre en una nueva pestaña

// 5. close(): Cierra la ventana actual o una ventana abierta con open.
window.close(); // Cierra la ventana actual (si fue abierta mediante JavaScript)
<br><br>En JavaScript, los datos de tipo texto se almacenan como cadenas. No hay un tipo char para un solo carácter. Los strings se representan mediante texto entrecomillado, existen 3 tipos de entrecomillado:<br>
<br>Comillas dobles o comillas simples: Permiten representar únicamente texto y en una sola línea.
<br>Los backticks: Además de representar las cadenas de texto, nos permiten incrustar cualquier expresión en la cadena, envolviéndola en ${…}. También permiten utilizar un formato multilínea.
<br>let nombre = "Juan";
let saludo = `Hola, ${nombre}`;
console.log(saludo); // Imprime "Hola, Juan"
<br><br>
<br>Literales de cadena:
<br>let saludo = "Hola, mundo!";
let nombre = 'Juan';
<br>
<br>Constructor String():
<br>let nombre = new String(‘Juan’);
<br><br>// 1. length: Devuelve la longitud de la cadena
let frase = "JavaScript es un lenguaje de programación";
console.log(`Longitud de la frase: ${frase.length}`);
<br><br>// 1. charAt(índice): Devuelve el carácter en la posición especificada por el índice.
let texto = "ABCDEFGHIJKLMN";
console.log(texto.charAt(5)); // Imprime "F" (carácter en la posición 5)

// 2. charCodeAt(índice): Devuelve el código Unicode del carácter en la posición especificada por el índice.
let letra = "ñ";
console.log(letra.charCodeAt(0)); // Imprime "165" (código Unicode de la letra "ñ")

// 3. indexOf(subcadena, inicio): Busca la primera aparición de una subcadena, devolviendo la posición de inicio.
let frase = "Esta frase contiene la palabra programación";
let indice = frase.indexOf("programación");
if (indice !== -1) {
  console.log(`programación está en la posición: ${indice}`);
} else {
  console.log("programación no se encuentra en la frase");
}

// 4. lastIndexOf(subcadena, inicio): Busca la última aparición de una subcadena, devolviendo la posición de inicio.
let texto2 = "Repetir la palabra palabra";
console.log(texto2.lastIndexOf("palabra")); // Imprime la posición de la última aparición de "palabra"

// 5. replace(subcadena, reemplazo): Reemplaza todas las apariciones de una subcadena por una cadena de reemplazo.
let texto3 = "Hola a todos, soy un robot";
let textoReemplazado = texto3.replace("robot", "humano");
console.log(textoReemplazado); // Imprime "Hola a todos, soy un humano"

// 6. toUpperCase() y toLowerCase(): Convierten la cadena a mayúsculas y minúsculas.
let saludo = "Hola Mundo";
console.log(saludo.toUpperCase()); // Imprime "HOLA MUNDO"
console.log(saludo.toLowerCase()); // Imprime "hola mundo"

// 7. trim(): Elimina los espacios en blanco al inicio y al final de la cadena.
let texto4 = "   Hola Mundo   ";
console.log(texto4.trim()); // Imprime "Hola Mundo"

// 8. concat(cadena2, ...): Concatena dos o más cadenas.
let nombre = "Juan";
let apellido = "Pérez";
let nombreCompleto = nombre.concat(" ", apellido);
console.log(nombreCompleto); // Imprime "Juan Pérez"

// 9. slice(inicio, fin): Extrae una subcadena desde una posición inicial hasta una posición final especificada.
let frase2 = "JavaScript es un lenguaje de programación";
let subcadena = frase2.slice(10, 25);
console.log(subcadena); // Imprime "es un lenguaje"

// 10. split(): Divide una cadena de texto en una lista de subcadenas, basado en un separador especificado.

	// Ejemplo 1: Dividir una cadena por espacios
	let frase3 = "Esta frase se divide por espacios";
	let palabras = frase3.split(" ");
	console.log(palabras); // Imprime ["Esta", "frase", "se", "divide", "por", "espacios"]

	// Ejemplo 2: Dividir una cadena por comas
	let lista = "rojo,verde,azul,amarillo";
	let colores = lista.split(",");
	console.log(colores); // Imprime ["rojo", "verde", "azul", "amarillo"]

	// Ejemplo 3: Dividir una cadena con un límite especificado
	let cadenaLarga = "Lorem ipsum dolor sit amet, consectetur adipiscing elit";
	let partes = cadenaLarga.split(" ", 5); // Límite de 5 subcadenas
	console.log(partes); // Imprime las primeras 5 palabras de la cadena

// Ejemplo 4: Obtener caracteres individuales
	let texto5 = "Hola, mundo!";
	let caracteres = texto5.split("");
	console.log(caracteres); // Imprime un array con cada carácter: ["H", "o", "l", "a", ",", " ", "m", "u", "n", "d", "o", "!"]
<br><br>El objeto Date en JavaScript representa un punto específico en el tiempo. Se utiliza para trabajar con fechas y horas, permitiendo obtener la fecha actual, crear fechas futuras o pasadas.<br><br>
<br>Sin argumentos: Crea un objeto Date con la fecha y hora actual según el reloj del sistema.
<br>let fechaActual = new Date();
console.log(fechaActual);
<br>
<br>Con argumentos: Permite crear un objeto Date con una fecha y hora específicas especificando valores numéricos para el año, mes, día, hora, minutos, segundos y milisegundos.
<br>let fechaEspecifica = new Date(2024, 5, 12, 10, 30, 15, 500);
console.log(fechaEspecifica); 
<br>
<br>Con cadena de fecha: Permite crear un objeto Date a partir de una cadena de texto que represente una fecha y hora en un formato específico.
<br>let fechaCadena = "2024-06-12T10:30:15.500+02:00";
let fechaObjeto = new Date(fechaCadena);
console.log(fechaObjeto);
<br><br>// 1. getFullYear(): Obtiene el año de la fecha como un número entero de cuatro dígitos.
let fecha = new Date();
let año = fecha.getFullYear();
console.log(`Año actual: ${año}`); // Ejemplo: 2024

// 2. getMonth(): Obtiene el mes de la fecha como un número entero de 0 a 11, donde 0 representa enero y 11 diciembre.
let mes = fecha.getMonth();
console.log(`Mes actual: ${mes + 1}`); // Ejemplo: 6 (junio)

// 3. getDate(): Obtiene el día del mes de la fecha como un número entero de 1 a 31.
let dia = fecha.getDate();
console.log(`Día actual: ${dia}`); // Ejemplo: 12

// 4. getHours(): Obtiene la hora de la fecha como un número entero de 0 a 23.
let hora = fecha.getHours();
console.log(`Hora actual: ${hora}`); // Ejemplo: 13

// 5. getMinutes(): Obtiene los minutos de la fecha como un número entero de 0 a 59.
let minutos = fecha.getMinutes();
console.log(`Minutos actuales: ${minutos}`); // Ejemplo: 26

// 6. getSeconds(): Obtiene los segundos de la fecha como un número entero de 0 a 59.
let segundos = fecha.getSeconds();
console.log(`Segundos actuales: ${segundos}`); // Ejemplo: 12

// 7. getMilliseconds(): Obtiene los milisegundos de la fecha como un número entero de 0 a 999.
let milisegundos = fecha.getMilliseconds();
console.log(`Milisegundos actuales: ${milisegundos}`);
<br><br>// 1. setFullYear(año): Establece el año de la fecha en el valor entero especificado.
let fecha = new Date();
fecha.setFullYear(2023); // Establece el año a 2023
console.log(fecha.getFullYear()); // Imprime: 2023

// 2. setMonth(mes): Establece el mes de la fecha en el valor especificado (de 0 a 11, donde 0 representa enero y 11 diciembre).
fecha.setMonth(4); // Establece el mes a mayo (mes 4)
console.log(fecha.getMonth() + 1); // Imprime: 5 (mayo)

// 3. setDate(día): Establece el día del mes de la fecha en el valor entero especificado (de 1 a 31).
fecha.setDate(10); // Establece el día a 10
console.log(fecha.getDate()); // Imprime: 10

// 4. setHours(hora): Establece la hora de la fecha en el valor entero especificado (de 0 a 23).
fecha.setHours(18); // Establece la hora a 18
console.log(fecha.getHours()); // Imprime: 18

// 5. setMinutes(minutos): Establece los minutos de la fecha en el valor entero especificado (de 0 a 59).
fecha.setMinutes(30); // Establece los minutos a 30
console.log(fecha.getMinutes()); // Imprime: 30

// 6. setSeconds(segundos): Establece los segundos de la fecha en el valor entero especificado (de 0 a 59).
fecha.setSeconds(15); // Establece los segundos a 15
console.log(fecha.getSeconds()); // Imprime: 15

// 7. setMilliseconds(milisegundos): Establece los milisegundos de la fecha en el valor entero especificado (de 0 a 999).
fecha.setMilliseconds(500); // Establece los milisegundos a 500
console.log(fecha.getMilliseconds()); // Imprime: 500
<br><br>Para trabajar con números y funciones matemáticas disponemos de dos objetos: Number y Math.<br><br>El objeto Number en JavaScript representa valores numéricos, tanto enteros como decimales.<br>// Propiedades de Number:
console.log(Number.MAX_VALUE); // Valor numérico más grande posible
console.log(Number.MIN_VALUE); // Valor numérico más pequeño posible
console.log(Number.POSITIVE_INFINITY); // Infinito positivo
console.log(Number.NEGATIVE_INFINITY); // Infinito negativo
console.log(Number.NaN); // Valor no numérico ("Not a Number")

// Métodos principales:
const numero = 123.4567;
console.log(numero.toString()); // Convierte a cadena de texto
console.log(numero.toFixed(2)); // "123.46" - Convierte a texto con 2 decimales
console.log(numero.toExponential(2)); // Notación exponencial: "1.23e+2"
console.log(numero.valueOf()); // Valor primitivo del número

// Métodos de comprobación:
console.log(Number.isFinite(numero)); // true - Comprueba si es finito
console.log(Number.isNaN('Hola')); // true - Comprueba si es NaN
console.log(Number.isInteger(numero)); // false - Comprueba si es un entero

// Convertir cadena a número:
const cadena = '100';
const numeroConvertido = Number(cadena);
console.log(numeroConvertido); // 100

// Crear un objeto Number con el constructor
const nuevoNumero = new Number(200);
console.log(nuevoNumero); // Imprime: Number {valueOf: 200}
<br><br>El objeto Math en JavaScript es un objeto global que proporciona constantes y funciones matemáticas. Es una herramienta esencial para trabajar con números en aplicaciones web.<br>// Constantes de Math:
console.log(Math.PI); // Valor de pi (aproximadamente 3.14159)
console.log(Math.E); // Número de Euler (aproximadamente 2.71828)
console.log(Math.LN2); // Logaritmo natural de 2
console.log(Math.LN10); // Logaritmo natural de 10
console.log(Math.SQRT2); // Raíz cuadrada de 2
console.log(Math.SQRT1_2); // Raíz cuadrada de 1/2

// Funciones aritméticas:
console.log(Math.abs(-5)); // Valor absoluto: 5
console.log(Math.pow(2, 3)); // Potencia: 2^3 = 8
console.log(Math.sqrt(16)); // Raíz cuadrada: 4
console.log(Math.floor(4.7)); // Redondea hacia abajo: 4
console.log(Math.ceil(4.3)); // Redondea hacia arriba: 5
console.log(Math.round(4.5)); // Redondea al más cercano: 5
console.log(Math.random()); // Genera un número aleatorio entre 0 y 1

// Funciones trigonométricas:
console.log(Math.sin(Math.PI / 2)); // Seno de π/2: 1
console.log(Math.cos(Math.PI)); // Coseno de π: -1
console.log(Math.tan(0)); // Tangente de 0: 0
console.log(Math.asin(1)); // Arcoseno de 1: π/2
console.log(Math.acos(0)); // Arcocoseno de 0: π/2
console.log(Math.atan(1)); // Arcotangente de 1: π/4
console.log(Math.atan2(1, 1)); // Arcotangente de 1/1: π/4

// Funciones de logaritmos:
console.log(Math.log(10)); // Logaritmo natural de 10
console.log(Math.log10(100)); // Logaritmo base 10 de 100: 2
console.log(Math.log2(8)); // Logaritmo base 2 de 8: 3
console.log(Math.exp(1)); // Exponencial de 1 (e^1): Math.E

// Funciones de redondeo:
console.log(Math.round(4.5)); // Redondea al más cercano: 5
console.log(Math.floor(4.7)); // Redondea hacia abajo: 4
console.log(Math.ceil(4.3)); // Redondea hacia arriba: 5

// Funciones de mínimo y máximo:
console.log(Math.max(1, 3, 2)); // Máximo: 3
console.log(Math.min(1, 3, 2)); // Mínimo: 1
<br><br>El almacenamiento de datos en JavaScript se maneja principalmente a través de cookies, Web Storage API (localStorage y sessionStorage) e IndexedDB.<br>
<br>Cookies: Son pequeñas piezas de datos que un servidor envía al navegador. Se almacenan como pares clave-valor y se usan para gestionar sesiones, personalizar contenido y rastrear actividad del usuario. Las cookies se configuran usando document.cookie y pueden tener un tiempo de expiración (con expires o max-age). Las cookies se envían con cada solicitud al servidor, lo que puede impactar el rendimiento, por lo que se recomiendan otras alternativas para almacenamiento.
<br>// Creación y manejo de cookies en JavaScript

// Crear cookies
document.cookie = "nombre=Pepe";
document.cookie = "edad=30";
document.cookie = "ciudad=Valencia";
alert("Cookies guardadas correctamente.");
console.log(document.cookie); // Mostrar todas las cookies

// Configuración de propiedades importantes
// 1. path: Accesibilidad de la cookie en todas las páginas
document.cookie = "ciudad=Valencia; path=/";

// 2. expires y max-age: Controlan la duración de la cookie
// Expira cuando el navegador se cierra si no se establece
// Explicación de expires
let date = new Date(Date.now() + 86400e3); // +1 día
document.cookie = "ciudad=Valencia; expires=" + date.toUTCString();

// Eliminar una cookie estableciendo expires en el pasado
document.cookie = "ciudad=Valencia; expires=Thu, 01 Jan 1970 00:00:00 GMT";

// Explicación de max-age
document.cookie = "nombre=Pepe; max-age=3600"; // Expira en 1 hora
document.cookie = "nombre=Pepe; max-age=0"; // Eliminar cookie inmediatamente
<br>
<br>Web Storage API:

<br>sessionStorage: Almacena datos durante la sesión del navegador; los datos se eliminan al cerrar el navegador.
<br>localStorage: Almacena datos de forma persistente en el navegador, incluso después de cerrarlo. Usa pares clave-valor, y los métodos más usados son setItem, getItem, removeItem y clear.


<br>// Uso de LocalStorage en JavaScript

// Almacenamiento local: persistente y basado en pares clave-valor

// 1. Almacenar datos
localStorage.setItem("nombre", "Juan Pérez");
localStorage.setItem("edad", 30);

// 2. Recuperar datos
let nombre = localStorage.getItem("nombre");
console.log(nombre); // Imprime: "Juan Pérez"
let edad = localStorage.getItem("edad");
console.log(edad); // Imprime: 30

// 3. Eliminar datos
localStorage.removeItem("nombre");
console.log(localStorage.getItem("nombre")); // Imprime: null
localStorage.removeItem("edad");
console.log(localStorage.getItem("edad")); // Imprime: null

// 4. Limpiar todo el almacenamiento local
localStorage.clear();
console.log(localStorage.getItem("nombre")); // Imprime: null
console.log(localStorage.getItem("edad")); // Imprime: null
<br>
<br>IndexedDB: Es una API avanzada para almacenar grandes cantidades de datos estructurados en el cliente, como archivos y blobs. Es útil para aplicaciones complejas y permite realizar búsquedas de alto rendimiento usando índices.
]]></description><link>2-objetos-predefinidos\objetos-predifinidos.html</link><guid isPermaLink="false">2- Objetos Predefinidos/Objetos predifinidos.md</guid><pubDate>Sun, 03 Nov 2024 17:37:56 GMT</pubDate></item><item><title><![CDATA[EVENTOS]]></title><description><![CDATA[ 
 <br><br>Un evento en JS es una acción u ocurrencia que sucede en un documento HTML, como hacer clic en un botón, mover el ratón, presionar una tecla o cargar una página. Estos eventos permiten que nuestras páginas web sean interactivas y respondan a las acciones del usuario.<br>Existen varios tipos de eventos:<br>- Eventos del Mouse<br>
- click: cuando se hace clic en un elemento (los dispositivos con pantalla táctil lo generan con un toque).<br>
- contextmenu: cuando se hace clic derecho en un elemento.<br>
- mouseover / mouseout: cuando el ratón está sobre un elemento o sale de él.<br>
- mousedown / mouseup: cuando se presiona / suelta el botón del ratón sobre un elemento.<br>
- mousemove: cuando se mueve el ratón.<br>- Eventos de Teclado<br>
- keydown: cuando se presiona una tecla.<br>
- keyup: cuando se suelta una tecla.<br>
- keypress: mientras se mantiene una tecla presionada.<br>- Eventos de Elementos de Formulario<br>
- submit: cuando el usuario envía un formulario &lt;form&gt;.<br>
- reset: cuando se borra el contenido de un formulario.<br>
- focus: cuando el visitante se centra en un elemento, por ejemplo, en un &lt;input&gt;.<br>
- change: cuando cambia el valor de algún elemento del formulario.<br>- Eventos del DOM:<br>
- load: cuando se carga y procesa el HTML; el DOM está completamente construido.<br>
- resize: cuando cambia el tamaño de la ventana del navegador.<br>
- scroll: cuando se desplaza la página.<br><br>Para reaccionar ante los eventos, podemos asignar un controlador, una función que se ejecuta cuando sucede un evento.<br>Hay varias formas:<br>
<br>Atributo HTML (no conveniente, utilizando onclick):
<br>&lt;!-- FORMA 1 --&gt;
&lt;button class="btn btn-primary" onclick="alert('Hola...')"&gt;Saludar&lt;/button&gt;

&lt;!-- FORMA 2 --&gt;
&lt;button class="btn btn-primary" onclick="saludar()"&gt;Saludar&lt;/button&gt;

&lt;script&gt;
function saludar(){
alert ("Hola...")
 }
&lt;/script&gt;
<br>
<br>Propiedades DOM (utilizando on&lt;event&gt;):
<br>&lt;body&gt; 
	&lt;button class="btn btn-primary" id="miBoton"&gt;Saludar&lt;/button&gt; 
&lt;/body&gt; 

&lt;script&gt; 
let miBoton=document.getElementById("miBoton") 

// FORMA 1
// ********

/* miBoton.onclick=saludar()*/ // ESTO NO FUNCIONARIA PORQUE LE ASIGNAMOS LA EJECUCIÓN DE LA FUNCIÓN
miBoton.onclick=saludar // ESTO SI FUNCIONA PORQUE ASIGNA LA FUNCIÓN

function saludar(){ 
	alert ("Hola...") 
}

// FORMA 2 - CON FUNCIÓN ANÓNIMA
// *******************************
miBoton.onclick=function(){
	alert ("Hola...")
}

// FORMA 2 - CON SINTAXIS fatArrow
// *******************************
miBoton2.onclick=()=&gt;alert ("Hola...")
&lt;/script&gt;
<br>
<br>
Listener de eventos (recomendado usar): El problema fundamental de las formas que hemos visto de asignar controladores es que no podemos asignar varios controladores a un evento. Si queremos ejecutar dos acciones diferentes con funciones diferentes no podemos asignar los dos controladores al mismo elemento, ya que el segundo reemplazara al primero. Nos gustaría asignar dos controladores de eventos para eso. Pero una nueva propiedad DOM sobrescribirá la existente. Para solucionar esto tenemos addEventListener y removeEventListener.

<br>Agregar un Listener de Evento: Usando addEventListener, puedes agregar varios manejadores a un mismo evento sin que se sobrescriban. 

// Definimos las funciones que queremos ejecutar cuando ocurra el evento
function handler1() {
    alert('Hola primera vez...');
}

function handler2() {
    alert('Hola segunda vez...');
}

// Seleccionamos el elemento
let miBoton = document.getElementById("miBoton");

// Asignamos ambos manejadores al mismo evento "click"
miBoton.addEventListener("click", handler1);
miBoton.addEventListener("click", handler2);


<br>Eliminar un Listener de Evento: Para poder eliminar un listener, es fundamental que la función manejadora (el handler) esté almacenada en una variable o declarada como función nombrada. Esto es necesario porque removeEventListener requiere exactamente la misma referencia de función que addEventListener. No es posible eliminar un listener si se pasó una función anónima, ya que sería una instancia diferente.

// Definimos la función del controlador
function handler() {
    alert('Hola...');
}

// Seleccionamos el elemento
let miBoton = document.getElementById("miBoton");

// Agregamos el listener con el manejador de evento
miBoton.addEventListener("click", handler);

// Eliminamos el listener usando el mismo manejador
miBoton.removeEventListener("click", handler);


<br><br>Cuando se hace click en un elemento dentro de una página web (por ejemplo, en un &lt;p&gt; que está dentro de un &lt;div&gt;), el navegador debe decidir en qué orden manejar esos eventos de clic entre los elementos involucrados (el &lt;p&gt; y el &lt;div&gt; en este caso). Existen dos formas de definir este orden:<br>
<br>
Bubbling (burbujeo): El evento se maneja primero en el elemento más profundo o interno (el hijo), y luego sube "haciendo burbuja" hacia los elementos contenedores. Si useCapture está en false, el evento burbujea.

<br>
Capturing (captura): El evento se maneja primero en el elemento más externo (el contenedor o padre), y luego pasa al elemento más interno (hijo). Si useCapture está en true, el evento captura.

<br>&lt;div id="myDiv"&gt;
    &lt;p&gt;Este es un div. Haz clic en el botón de abajo:&lt;/p&gt;
    &lt;button id="myButton"&gt;¡Haz clic aquí!&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
// Funciones para manejar los eventos de clic
function clickOnDiv() {
    alert("Click en el DIV de fondo coral");
}

function clickOnButton() {
	alert("Click en el BOTÓN de fondo blanco");
}

// Añadimos los eventos para el div y el botón con bubbling y capturing

// *********************************   CASO 1   **********************************
// Bubbling (burbujeo): de adentro hacia afuera
// Primero muestra clickOnButton(), luego clickOnDiv()
document.getElementById("myButton").addEventListener("click", clickOnButton, false);
document.getElementById("myDiv").addEventListener("click", clickOnDiv, false);

// *********************************   CASO 2   **********************************
// Capturing (captura): de afuera hacia adentro
// Primero muestra clickOnDiv(), luego clickOnButton()
document.getElementById("myButton").addEventListener("click", clickOnButton, true);
document.getElementById("myDiv").addEventListener("click", clickOnDiv, true);
&lt;/script&gt;

<br><br>El objeto Event se utiliza para manejar eventos (como clics de ratón o pulsaciones de teclado) de forma más detallada. Este objeto contiene información adicional sobre el evento que se activó, permitiendo, por ejemplo, conocer las coordenadas del ratón o la tecla específica que se presionó.<br>
<br>
Ejemplo básico: Al producirse un evento, el navegador crea un objeto Event que contiene todos los detalles del evento. Este objeto se pasa automáticamente al controlador que maneja el evento, lo que permite acceder a propiedades como:

<br>event.type: indica el tipo de evento, como "click".
<br>event.currentTarget: hace referencia al elemento que disparó el evento.
<br>event.clientX y event.clientY: representan las coordenadas del cursor en la ventana al momento del evento.


<br>
Ejemplo en código: En este ejemplo, al hacer clic en un botón, se muestra una alerta con el tipo de evento y las coordenadas del cursor:

<br>&lt;button id="miBoton"&gt;Haz click...&lt;/button&gt;
&lt;script&gt;
let miBoton = document.getElementById("miBoton");
miBoton.onclick = function(event) {
    alert("Evento " + event.type + " en " + event.currentTarget);
    alert("Coordenadas: " + event.clientX + ":" + event.clientY);
};
&lt;/script&gt;
<br><br>Para acceder a los elementos del DOM (Document Object Model) en una página web, esta debe cargarse completamente, es decir, todos los elementos deben estar listos. Si intentamos usar JavaScript en el DOM antes de que la página termine de cargar, obtendremos errores porque los elementos aún no existen.<br>Existen varias formas de asegurarse de que el código JavaScript acceda al DOM solo cuando la página ya está lista:<br>
<br>
Ubicación de los Scripts: Colocar los scripts de JavaScript al final del &lt;body&gt;, para que se ejecuten una vez que el contenido de la página esté cargado.

<br>
Uso del evento onload: Este evento se activa cuando la página está completamente cargada.

<br>
Con el atributo HTML: En la etiqueta &lt;body&gt;, podemos usar onload para llamar a una función cuando la página esté lista.

<br>
Con el objeto window: También podemos usar window.onload para asegurarnos de que toda la página (incluido el body) esté cargada.
 Ejemplos:

<br>Llamar a una función existente con window.onload = nombreFuncion;
<br>Usar una función anónima: window.onload = function() { /* código */ }
<br>Usar una función "arrow" (fat arrow): window.onload = () =&gt; { /* código */ }




<br>
addEventListener: Otra opción es usar addEventListener("load", ...) sobre window para ejecutar el código una vez que la página esté cargada.

<br>Funciona con una función existente, función anónima, o con "fat arrow".


<br><br>Los eventos personalizados son creados por los desarrolladores para representar acciones o estados específicos en una aplicación, permitiendo comunicación entre diferentes partes del código de manera flexible y desacoplada. Esto facilita la creación de flujos de trabajo específicos y la simplificación del código.<br>- Beneficios de los eventos personalizados<br>
- Comunicación entre componentes: Facilitan la comunicación entre distintas partes de una aplicación sin necesidad de conexiones directas.<br>
- Flujos de trabajo personalizados: Permiten crear eventos específicos para situaciones no cubiertas por los eventos nativos.<br>
- Código más claro: Encapsulan la lógica de interacción, mejorando la legibilidad y el mantenimiento.<br><br>Para crear un evento personalizado, se usa el constructor CustomEvent, que recibe:<br>
<br>Nombre del evento: Identifica el evento.
<br>Opciones: Objeto con propiedades como bubbles (si el evento se propaga), cancelable (si puede cancelarse) y detail (datos adicionales).
<br>Ejemplo:<br>const myEvent = new CustomEvent('myCustomEvent', {
    detail: {
        message: 'Hola desde el evento personalizado',
        data: 42
    }
});
<br>Para lanzarlo, usamos dispatchEvent() sobre un elemento (en el ejemplo, sobre window):<br>window.dispatchEvent(myEvent);
<br><br>Para capturar el evento, se usa addEventListener() de forma similar a los eventos nativos. En el ejemplo, se accede a event.detail para obtener los datos:<br>window.addEventListener('myCustomEvent', (event) =&gt; {
    console.log(event.detail.message); // "Hola desde el evento personalizado"
});
<br><br>Un botón lanza el evento personalizado al hacer clic, y un listener captura y maneja el evento:<br>&lt;body&gt;
    &lt;button id="miBoton"&gt;Lanzar evento&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
    const myEvent = new CustomEvent('myCustomEvent', {
        detail: { message: 'Hola desde el evento personalizado', data: 42 }
    }); // crear evento
    
    let miBoton = document.getElementById("miBoton"); // asocia a elemto HTML una variable
    
    miBoton.addEventListener("click", () =&gt; window.dispatchEvent(myEvent)); // lanzamos evento
    window.addEventListener('myCustomEvent', (event) =&gt; {
        console.log(event.detail.message); // "Hola desde el evento personalizado"
    });
&lt;/script&gt;
]]></description><link>3-eventos\eventos.html</link><guid isPermaLink="false">3- Eventos/Eventos.md</guid><pubDate>Mon, 04 Nov 2024 11:59:45 GMT</pubDate></item><item><title><![CDATA[EL DOM <em>(Modelo de objeto de documento)</em>]]></title><description><![CDATA[ 
 <br><br>El DOM define un estándar para acceder a los documentos: "El Modelo de objetos de documento (DOM) del W3C es una plataforma y una interfaz de lenguaje neutral que permite que los programas y los scripts accedan y actualicen dinámicamente el contenido, la estructura y el estilo de un documento"<br>Cuando se carga una página web, el navegador crea el DOM (Document Model Object)<br>
<br>Modelo: Significa que el DOM ofrece una representación estructurada de tu documento HTML.
<br>Objeto: Cada elemento del DOM es un objeto al que puedes acceder y manipular con JavaScript.
<br>Documento: Se refiere a la página HTML. 
<br>El modelo HTML DOM se construye como un árbol de objetos. Con este, JavaScript obtiene toda la potencia que necesita para crear HTML dinámico:<br>
<br>JavaScript puede cambiar todos los elementos HTML en la página
<br>JavaScript puede cambiar todos los atributos HTML en la página
<br>JavaScript puede cambiar todos los estilos CSS en la página
<br>JavaScript puede eliminar elementos y atributos HTML existentes
<br>JavaScript puede agregar nuevos elementos y atributos HTML
<br>JavaScript puede reaccionar a todos los eventos HTML existentes en la página
<br>JavaScript puede crear nuevos eventos HTML en la página
<br><br>El HTML DOM es un modelo de objetos estándar y una interfaz de programación para HTML que define cómo obtener, modificar, agregar o eliminar elementos HTML.<br><br>Se puede acceder al HTML DOM con JavaScript. En el DOM, todos los elementos HTML se definen como objetos. La interfaz de programación son las propiedades y métodos de cada objeto.<br>
<br>Una propiedad es un valor que puede obtener o establecer (como cambiar el contenido de un elemento HTML).
<br>Un método es una acción que puede hacer (como agregar o eliminar un elemento HTML).
<br>Por ejemplo:<br>
<br>getElementById es un método que accede a un elemento por el ID.
<br>innerHTML es una propiedad para obtener o remplazar el contenido de elementos HTML.
<br>&lt;html&gt;
	&lt;body&gt;
		&lt;p id="demo"&gt;&lt;/p&gt;
		
		&lt;script&gt;
			document.getElementById("demo").innerHTML = "Hello World!";
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;
<br><br>El DOM (Document Object Model) representa la estructura de la página web. Para acceder y manipular elementos HTML, usamos el objeto document. Aquí hay algunos ejemplos:<br>// ********************************************************************************
// Encontrar elementos HTML

document.getElementById("id");             // Encuentra un elemento por su ID
document.getElementsByTagName("name");     // Encuentra elementos por etiqueta HTML
document.getElementsByClassName("name");   // Encuentra elementos por clase CSS
document.querySelector("css");             // Selecciona el primer elemento que coincida con el selector CSS
document.querySelectorAll("css");          // Selecciona todos los elementos que coincidan con el selector CSS

// ********************************************************************************
// Cambiar elementos HTML

// Propiedades
element.innerHTML = "nuevo contenido";     // Cambia el contenido HTML de un elemento
element.attribute = "nuevo valor";         // Cambia el valor de un atributo de un elemento HTML
element.style.property = "nuevo estilo";   // Cambia el estilo de un elemento HTML

// Métodos
element.setAttribute("attribute", "value"); // Cambia el valor de un atributo de un elemento HTML
// Nota: `setAttribute` es un método que requiere el nombre y valor del atributo como argumentos.

// ********************************************************************************
// Añadir y eliminar elementos

document.createElement("element");         // Crea un nuevo elemento HTML
document.removeChild(element);             // Elimina un elemento HTML
document.appendChild(element);             // Añade un elemento HTML como hijo de otro
document.replaceChild(newElement, oldElement); // Reemplaza un elemento HTML por otro
document.write("texto");                   // Escribe texto o HTML directamente en la página

// ********************************************************************************
// Agregar controladores de eventos

document.getElementById("id").onclick = function() {
  // Código para gestionar el evento `onclick` del elemento con el ID especificado
};

// ********************************************************************************
// Encontrar objetos HTML

// HTML DOM Nivel 1 (1998) define 11 objetos HTML que siguen válidos en HTML5
document.anchors;      // Anclas en el documento
document.body;         // Cuerpo del documento
document.cookie;       // Cookies del documento
document.doctype;      // Tipo de documento
document.forms;        // Formularios en el documento
document.images;       // Imágenes en el documento
document.links;        // Enlaces en el documento
document.readyState;   // Estado de carga del documento
<br><br>De acuerdo con el estándar W3C HTML DOM, todo en un documento HTML es un nodo:<br>
<br>Todo el documento es un nodo de documento.
<br>Cada elemento HTML es un nodo de elemento.
<br>El texto dentro de los elementos HTML son nodos de texto.
<br>Cada atributo HTML es un nodo de atributo (en desuso).
<br>Todos los comentarios son nodos de comentarios.
<br>Los nodos son objetos que forman el DOM y como tal tienen propiedades y métodos. Las propiedades son atributos que permiten identificar el nodo y saber su relación con el resto del DOM. Vamos a ver las propiedades más importantes.<br><br>// Propiedad `nodeName`: especifica el nombre de un nodo.
let elemento = document.getElementById("h1");
alert(elemento.nodeName); // Muestra "H1"

// - `nodeName` es de solo lectura.
// - Para un nodo de elemento, `nodeName` es el nombre de la etiqueta en MAYÚSCULAS.
// - Para un nodo de atributo, `nodeName` es el nombre del atributo.
// - Para un nodo de texto, `nodeName` siempre es "#text".
// - Para el nodo de documento, `nodeName` siempre es "#document".

// ********************************************************************************
// Propiedad `nodeValue`: especifica el valor de un nodo.
console.log(elemento.nodeValue);          // `null` para nodos de elemento
console.log(elemento.firstChild.nodeValue); // Texto de un nodo de texto

// - Para elementos de nodo, `nodeValue` es `null`.
// - Para nodos de texto, `nodeValue` es el texto en sí.
// - Para nodos de atributo, `nodeValue` es el valor del atributo.

// ********************************************************************************
// Propiedad `nodeType`: devuelve el tipo de un nodo. Es de solo lectura.

console.log(elemento.nodeType); // Devuelve 1 para ELEMENT_NODE

// Tipos de nodos más comunes:
const nodeTypes = {
  ELEMENT_NODE: 1,       // &lt;h1 class="heading"&gt;Titulo&lt;/h1&gt;
  ATTRIBUTE_NODE: 2,     // class = "heading" (obsoleto)
  TEXT_NODE: 3,          // Texto de un elemento
  COMMENT_NODE: 8,       // &lt;!-- This is a comment --&gt;
  DOCUMENT_NODE: 9,      // El documento HTML mismo (padre de &lt;html&gt;)
  DOCUMENT_TYPE_NODE: 10 // &lt;!Doctype html&gt;
};
<br><br>// Propiedades para navegar entre nodos
let nodoEjemplo = document.getElementById("p1");

let nodoPadre = nodoEjemplo.parentNode;             // Nodo padre de un nodo
let nodoHijos = nodoEjemplo.childNodes;             // Colección de hijos de un nodo
let primerHijo = nodoEjemplo.firstChild;            // Primer hijo de un nodo
let ultimoHijo = nodoEjemplo.lastChild;             // Último hijo de un nodo
let siguienteHermano = nodoEjemplo.nextSibling;     // Siguiente nodo hermano
let anteriorHermano = nodoEjemplo.previousSibling;  // Anterior nodo hermano

// ********************************************************************************
// Nodos secundarios y valores de nodo
// Un nodo de elemento no contiene texto directamente, sino un nodo de texto con el valor.

&lt;p id="p1"&gt;Tutorial DOM&lt;/p&gt;;

let miP1 = document.getElementById("p1").innerHTML;           // "Tutorial DOM"
let miP2 = document.getElementById("p1").firstChild.nodeValue; // "Tutorial DOM"
let miP3 = document.getElementById("p1").childNodes[0].nodeValue; // "Tutorial DOM"

// Ejemplo: copiar el texto de un &lt;h1&gt; a un &lt;p&gt; en tres formas
&lt;h1 id="h1"&gt;Mi pagina&lt;/h1&gt;
&lt;p id="p1"&gt;&lt;/p&gt;

&lt;script&gt;

document.getElementById("p1").innerHTML = document.getElementById("h1").innerHTML;
document.getElementById("p1").innerHTML=document.getElementById("h1").firstChild.nodeValue;

document.getElementById("p1").innerHTML=document.getElementById("h1").childNodes[0].nodeValue;

&lt;/script&gt;

// Nota: `innerHTML` es un método rápido para acceder al contenido HTML, pero conocer otros métodos ayuda a entender la estructura de árbol y navegación del DOM.

// Para nodos de texto, también se puede acceder al contenido mediante `textContent`.
let textoNodo = document.getElementById("demo").textContent;
<br><br>Como vimos anteriormente al lenguaje se le incorporaron objetos y colecciones para agrupar elementos concretos. Podemos realizar búsquedas sobre esos elementos también. Es decir:<br>let misImagenes= document.images // podemos acceder a todas las imagenes del documento
let misLinks= document.links // podemos acceder a todos las links del documento
let misForms=document.forms // podemos acceder a todos las formularios del documento 
<br><br>Una vez que hemos accedido a los elementos del DOM con cualquiera de las formas que hemos visto, podemos modificar las propiedades de los elementos modificando dinámicamente los elementos HTML de nuestra página. Las modificaciones son de dos tipos de atributos o de estilo CSS.<br>
<br>Atributo: elemento.atributo=valor.
<br>&lt;img id="miImagen" src="imagen1.gif"&gt; 

&lt;script&gt; 
	document.getElementById("miImagen").src = "imagen2.jpg"; 
&lt;/script&gt;
<br>
<br>Estilo: elemento.style.property = estilo.
<br>&lt;p id="p1"&gt;Hola mundo!&lt;/p&gt; 

&lt;script&gt;
	document.getElementById("p1").style.color = "blue"; 
&lt;/script&gt;
<br><br>Hasta ahora hemos accedido a elementos que ya existían en el DOM y una vez que teníamos acceso hemos podido modificarle las propiedades. En muchas ocasiones lo que vamos a necesitar es crear, modificar, eliminar o clonar nodos.<br><br>let imagen = document.createElement("img");  // Crear nodo &lt;img&gt;
imagen.id = "mi_foto";  // Asignar id
imagen.src = "./fotos/logo.jpg";  // Asignar src para definir la imagen

// Añadir imagen al contenedor 'fotos'
let divFotos = document.getElementById("fotos");
divFotos.appendChild(imagen);  // Insertar nodo en el DOM

// Ejemplo con nodo de texto
let miParrafo = document.createElement("p");  // Crear nodo &lt;p&gt;
let miTexto = document.createTextNode("Texto del parrafo.");  // Crear nodo de texto
miParrafo.appendChild(miTexto);  // Agregar texto al &lt;p&gt;

// Añadir párrafo al contenedor 'div1'
let padre = document.getElementById("div1");
padre.appendChild(miParrafo);  // Insertar nodo en el DOM

// textContent para acceder o cambiar texto sin crear nodo de texto
const parrafo = document.getElementById("miParrafo");
console.log(parrafo.textContent);  // Obtener contenido de texto
parrafo.textContent = "Nuevo contenido para el párrafo.";  // Cambiar contenido

// insertBefore para añadir en una posición específica
let miparrafo = document.createElement("p");
let miTexto2 = document.createTextNode("Parrafo nuevo");
miparrafo.appendChild(miTexto2);
let elementoHijo = document.getElementById("p1");  // Nodo de referencia
padre.insertBefore(miparrafo, elementoHijo);  // Insertar antes de elementoHijo
<br><br>let parrafoEliminar = document.getElementById("p1");
parrafoEliminar.remove();  // Eliminar nodo directamente
<br><br>let nuevoParrafo = document.createElement("p");
let nodoTexto = document.createTextNode("Parrafo nuevo");
nuevoParrafo.appendChild(nodoTexto);
let child = document.getElementById("p1");  // Nodo a reemplazar
padre.replaceChild(nuevoParrafo, child);  // Reemplazar nodo
<br><br>// Método cloneNode(deep): deep = true copia el nodo y todos los descendientes
let clon = document.getElementById("miParrafo").cloneNode(true);
<br><br>Los eventos permiten ejecutar funciones en respuesta a acciones del usuario (clic, cambio, tecla pulsada, etc.).<br>// Asignación de evento onclick a un botón existente para mostrar la hora actual
document.getElementById("btn1").onclick = displayDate;

function displayDate() {
    document.getElementById("p1").innerHTML = Date();  // Muestra la fecha y hora actuales en el párrafo
}

// Crear un nuevo botón y asignarle un evento onclick usando una función anónima
let miBoton = document.createElement("button");        // Crear nodo &lt;button&gt;
miBoton.innerHTML = "Púlsame...";                      // Asignar texto al botón

miBoton.onclick = function() {                         // Asignar función anónima al evento onclick
    alert(this.innerHTML);                             // Muestra el texto del botón en un alert
};

document.body.appendChild(miBoton);                    // Añadir el botón al body
]]></description><link>4-dom\dom.html</link><guid isPermaLink="false">4- DOM/DOM.md</guid><pubDate>Wed, 06 Nov 2024 14:21:03 GMT</pubDate></item><item><title><![CDATA[FORMULARIOS]]></title><description><![CDATA[ 
 <br><br>Los formularios HTML son elementos fundamentales en la creación de páginas web interactivas. Permiten a los usuarios introducir datos, realizar selecciones y enviar información al servidor para su procesamiento. Sin embargo, los formularios básicos HTML pueden resultar limitados en cuanto a la funcionalidad y la experiencia del usuario. Es aquí donde JavaScript entra en juego, proporcionando herramientas para mejorar la interacción con los formularios y añadir características avanzadas.<br>Algunos usos de los formularios son:<br>
<br>Registro de usuarios
<br>Contacto
<br>Búsqueda
<br>Compras online
<br>Comentarios
<br>La estructura básica de un formulario es la siguiente:<br>&lt;form name="registro"&gt; 
	&lt;label for="nombre"&gt;Nombre:&lt;/label&gt; 
	&lt;input type="text" id="nombre" name="nombre"&gt; 
	
	&lt;label for="correo"&gt;Correo electrónico:&lt;/label&gt; 
	&lt;input type="email" id="correo" name="correo"&gt; 
	
	&lt;button type="submit"&gt;Enviar&lt;/button&gt; 
&lt;/form&gt;
<br>Algunos elementos de los formularios son:<br>
<br>Campos de entrada (&lt;input&gt;): Permiten a los usuarios introducir datos de texto, números, fechas, contraseñas, etc.
<br>Casillas de verificación (&lt;input type="checkbox"&gt;): Permiten a los usuarios seleccionar múltiples opciones.
<br>Botones de opción (&lt;input type="radio"&gt;): Permiten a los usuarios seleccionar una única opción de un grupo.
<br>Menús desplegables (&lt;select&gt;): Permiten a los usuarios seleccionar una opción de una lista.
<br>Botones (&lt;button&gt;): Inician una acción cuando se hace clic, como enviar el formulario o restablecer los campos.
<br>Etiquetas (&lt;label&gt;): Proporcionan texto descriptivo para los campos de entrada.
<br>Algunos atributos de los formularios son: <br>
<br>id: Un identificador único para el elemento.
<br>name: El nombre del elemento, utilizado para enviar los datos del formulario al servidor.
<br>type: El tipo de elemento, como text, email, checkbox, radio, etc.
<br>value: El valor inicial del elemento.
<br>required: Indica si el campo es obligatorio.
<br>placeholder: Texto de marcador que se muestra dentro del campo cuando está vacío.
<br><br>JavaScript permite interactuar con los formularios HTML de forma dinámica y agregar funcionalidades que no son posibles con HTML puro.<br><br>Para interactuar con los elementos de un formulario en JavaScript, primero hay que acceder a ellos. Esto se puede hacer utilizando diferentes métodos, como:<br>
<br>document.getElementById(id): Obtiene un elemento por su ID.
<br>document.querySelector(selector): Obtiene un elemento que coincida con un selector CSS.
<br>document.forms[nombre]: Obtiene un formulario por su nombre.
<br>form.elements[nombre]: Obtiene un elemento dentro de un formulario por su nombre.
<br>Ejemplo de acceso a elementos de un formulario:<br>&lt;script&gt;
  const nombreInput = document.getElementById('nombre');
  const emailInput = document.querySelector('input[name="correo"]');
  const formulario = document.forms['registro'];
  const botonEnviar = formulario.elements['enviar'];
&lt;/script&gt;
<br>Una vez que tenemos acceso a un elemento del formulario, podemos obtener su valor actual o modificarlo. Para obtener el valor, se utiliza la propiedad value. Para modificarlo, se asigna un nuevo valor a la propiedad value.<br><br>Los eventos son acciones que ocurren en un elemento o en la página web. En el contexto de los formularios, algunos eventos comunes son:<br>
<br>submit: Se dispara cuando se envía el formulario.
<br>change: Se dispara cuando se cambia el valor de un campo.
<br>focus: Se dispara cuando un campo recibe el foco.
<br>blur: Se dispara cuando un campo pierde el foco.
<br>Para gestionar eventos en formularios, se utilizan los manejadores de eventos. Estos manejadores son funciones que se ejecutan cuando se produce el evento correspondiente. Se pueden asociar a los elementos del formulario utilizando diferentes métodos, como:<br>
<br>on: agrega un manejador DOM.
<br>addEventListener: Agrega un manejador de eventos a un elemento.
<br>removeEventListener: Elimina un manejador de eventos de un elemento.
<br>// 1. Evento 'change': Se dispara cuando cambia el valor de un campo
// En este caso, comprobamos el valor escrito en el campo 'nombre'
const nombreInput = document.getElementById('nombre');
nombreInput.addEventListener('change', function() {
    const nombre = nombreInput.value;
    console.log('El nombre ha cambiado a:', nombre);
});

// 2. Evento 'focus' y 'blur': Enfoque y desenfoque de un campo
// Podemos mostrar mensajes cuando el campo recibe o pierde el foco
nombreInput.addEventListener('focus', function() {
    console.log('El campo de nombre ha recibido el foco');
});

nombreInput.addEventListener('blur', function() {
    console.log('El campo de nombre ha perdido el foco');
});

// 3. Evento 'submit': Envío del formulario
// Se usa generalmente para validar y enviar datos
const formulario = document.getElementById('miFormulario');
formulario.addEventListener('submit', function(event) {
    event.preventDefault(); // Evita el envío del formulario por defecto
    // Validar los datos del formulario aquí
    if (nombreInput.value === '') {
        console.log('El campo de nombre está vacío');
        return; // Detener el proceso si el campo está vacío
    }
    // Si los datos son válidos, se podría enviar el formulario aquí
    console.log('Formulario enviado con éxito');
});
<br><br>// Manejador de evento submit para validación previa
formulario.addEventListener('submit', function(event) {
    event.preventDefault(); // Evita el envío por defecto
    // Validación de los datos
    if (nombreInput.value === '') {
        console.log('Por favor, complete el campo de nombre');
    } else {
        console.log('Datos del formulario válidos, listos para enviar');
    }
});
<br><br>La validación de formularios permite verificar que los datos ingresados por el usuario son correctos y completos. En JavaScript, podemos realizar validaciones básicas con métodos para cadenas y números, y validaciones más complejas usando expresiones regulares (regex).<br>Las expresiones regulares son patrones para buscar y validar texto. Algunas aplicaciones incluyen:<br>
<br>Validación de datos: Para formatos específicos como correos electrónicos y números de teléfono.
<br>Búsqueda y extracción: Encontrar coincidencias en texto.
<br>Procesamiento de texto: Transformar y manipular cadenas.
<br>Ejemplo de validación de correo electrónico con regex:<br>// Función para validar un correo electrónico usando una expresión regular
function validarEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; // Patrón de regex básico para correos
    return regex.test(email); // Devuelve true si el email es válido
}

// Evento para validar el correo al perder el foco en el campo de email
const emailInput = document.getElementById('email');
emailInput.addEventListener('blur', function() {
    const email = emailInput.value;
    if (!validarEmail(email)) {
        alert('El correo electrónico no es válido.');
    }
});
<br><br>Este ejemplo valida:<br>
<br>Campo Nombre: No vacío, al menos 5 caracteres.
<br>Campo Email: No vacío, con formato válido de email.
<br>Muestra errores si hay algún problema y solo envía el formulario cuando todos los datos son válidos.
<br>// Validación del campo Nombre y Email
function validarFormulario() {
    let errores = false;
    
    // Validación del nombre
    const nombreInput = document.getElementById('nombre');
    const nombreError = document.getElementById('nombreError');
    if (nombreInput.value === '' || nombreInput.value.length &lt; 5) {
        nombreError.style.display = 'block';
        nombreError.textContent = 'El nombre debe tener al menos 5 caracteres';
        errores = true;
    } else {
        nombreError.style.display = 'none';
    }

    // Validación del correo electrónico
    const emailInput = document.getElementById('email');
    const emailError = document.getElementById('emailError');
    if (emailInput.value === '' || !validarEmail(emailInput.value)) {
        emailError.style.display = 'block';
        emailError.textContent = 'Ingrese un correo electrónico válido';
        errores = true;
    } else {
        emailError.style.display = 'none';
    }

    // Si no hay errores, mostrar un mensaje de éxito
    if (!errores) {
        alert('Los datos se han enviado con éxito.');
    }
    return !errores; // Devuelve false si hay errores para evitar el envío
}

// Manejador del evento 'submit' del formulario
let formulario = document.getElementById('miFormulario');
formulario.addEventListener('submit', function(event) {
    event.preventDefault(); // Evita el envío del formulario si hay errores
    validarFormulario();
    //formulario.submit();
});
<br>Detalles Importantes<br>
<br>Divs de error: Añadir debajo de cada campo un div oculto para mostrar mensajes de error.
<br>Validación en submit: Realizar todas las validaciones antes de enviar.
<br>Manejo de Errores: Mostrar mensajes de error específicos para cada campo inválido.
<br><br>JavaScript permite manipular fácilmente los elementos de un formulario, como cuadros de texto, radio buttons, checkboxes, y selects. A continuación, se presentan ejemplos para cada tipo de control.<br><br>Podemos obtener y establecer el valor de los cuadros de texto (&lt;input type="text"&gt;) y áreas de texto (&lt;textarea&gt;) usando la propiedad value.<br>// Obtener valores de un input y un textarea
const valorText = document.getElementById("texto").value;
const valorTextArea = document.getElementById("parrafo").value;
<br>Además, es posible definir campos como ocultos (type="hidden") o de solo lectura (readonly).<br><br>Los radio buttons permiten seleccionar solo una opción de un grupo. Para verificar cuál de ellos está seleccionado, usamos la propiedad checked.<br>// Obtener el estado de selección de cada radio button
let elementos = document.getElementsByName("estadoCivil");
Array.from(elementos).forEach(ec =&gt; console.log(`${ec.value} es ${ec.checked ? 'seleccionado' : 'no seleccionado'}`));
<br><br>Los checkboxes son similares a los radio buttons, pero permiten selecciones múltiples. Podemos comprobar si cada checkbox está seleccionado también con la propiedad checked.<br>// Verificar la selección de checkboxes
function verCondicionesPrivacidad() {
    const condiciones = document.getElementById("condiciones").checked ? " se ha aceptado" : " no se ha aceptado";
    
    const privacidad = document.getElementById("privacidad").checked ? " se ha aceptado" : " no se ha aceptado";
    
    console.log(`Condiciones: ${condiciones}, Privacidad: ${privacidad}`);
}
<br><br>Las listas desplegables (&lt;select&gt;) contienen una colección de opciones (&lt;option&gt;), y su valor puede obtenerse mediante la propiedad value.<br>// Obtener el valor seleccionado de un select
let lista = document.getElementById("lista");
console.log("Valor seleccionado:", lista.value);

lista.addEventListener("change", () =&gt; console.log("Nuevo valor:", lista.value));
<br>Para acceder a la posición o modificar la lista:<br>
<br>options es un array con todas las opciones.
<br>selectedIndex indica el índice de la opción seleccionada.
<br>// Acceder a una opción específica del select
let indiceSeleccionado = lista.selectedIndex;
let opcionSeleccionada = lista.options[indiceSeleccionado];
console.log("Texto seleccionado:", opcionSeleccionada.text);
console.log("Valor seleccionado:", opcionSeleccionada.value);
<br><br>Es posible agregar y eliminar opciones de un &lt;select&gt; de forma dinámica usando add y remove.<br>// Añadir una opción a la lista
function anyadirElementoLista() {
    let texto = prompt("Dime Texto");
    let valor = prompt("Dime Valor");
    let mioption = document.createElement("option");
    mioption.value = valor;
    mioption.text = texto;
    lista.appendChild(mioption);
}

// Eliminar una opción de la lista
function eliminarElementoLista(indice) {
    if (lista.options.length &gt; 0) {
        lista.remove(indice);
    }
}
<br><br>// Ejemplo de manipulación de controles en formulario
document.getElementById("submitBtn").addEventListener("click", function(event) {
    event.preventDefault();

    // Cuadro de texto y textarea
    let nombre = document.getElementById("nombre").value;
    let mensaje = document.getElementById("mensaje").value;
    console.log("Nombre:", nombre, "Mensaje:", mensaje);

    // Radio Button
    let estadoCivilSeleccionado = Array.from(document.getElementsByName("estadoCivil"))
        .find(rb =&gt; rb.checked);
    console.log("Estado Civil Seleccionado:", estadoCivilSeleccionado ? estadoCivilSeleccionado.value : "Ninguno");

    // Checkbox
    let aceptaCondiciones = document.getElementById("condiciones").checked;
    console.log("Acepta Condiciones:", aceptaCondiciones);

    // Select
    let lista = document.getElementById("lista");
    let valorSeleccionado = lista.value;
    console.log("Valor Seleccionado de Lista:", valorSeleccionado);
});
]]></description><link>5-formularios\formularios.html</link><guid isPermaLink="false">5- Formularios/Formularios.md</guid><pubDate>Thu, 14 Nov 2024 15:54:40 GMT</pubDate></item><item><title><![CDATA[API REST]]></title><description><![CDATA[ 
 <br><br>Se conoce como API (Application Programming Interface), o Interfaz de programación de Aplicaciones al conjunto de rutinas, funciones y procedimientos (métodos) que permite utilizar recursos de un software por otro, sirviendo como una capa de abstracción o intermediario.<br><br>La arquitectura REST (Representational State Transfer) trabaja sobre el protocolo HTTP. Por consiguiente, los procedimientos o métodos de comunicación son los mismos que HTTP, siendo los principales: GET, POST, PUT, PATCH y DELETE. Otros métodos que se utilizan en REST API son OPTIONS y HEAD.<br>Otro componente de un REST API es el HTTP Status Code, que le informa al cliente o consumidor del API que debe hacer con la respuesta recibida.<br>Por lo general y mejor práctica, el cuerpo (Body) de la respuesta de un API es una estructura en formato jSON.<br>Las principales ventajas del uso de una API REST son:<br>
<br>Separación entre el cliente y el servidor: el protocolo REST separa totalmente la interfaz de usuario del servidor y el almacenamiento de datos.
<br>Visibilidad, fiabilidad y escalabilidad: la separación entre cliente y servidor tiene una ventaja evidente y es que cualquier equipo de desarrollo puede escalar el producto sin excesivos problemas.
<br>La API REST siempre es independiente del tipo de plataformas o lenguajes: la API REST siempre se adapta al tipo de sintaxis o plataformas con las que se estén trabajando
<br><br>Las llamadas a una API REST permiten realizar operaciones CRUD (Crear, Leer, Actualizar y Borrar) en recursos de una base de datos, usando peticiones HTTP:<br>
<br>Crear (POST): Envía el recurso a añadir en la petición.
<br>Leer (GET): Devuelve todos los registros de una entidad o uno específico si se proporciona un id en la URL.
<br>Actualizar (PUT y PATCH):

<br>PUT actualiza todos los datos de un recurso.
<br>PATCH actualiza solo los campos específicos indicados, aunque no siempre es soportado.


<br>Eliminar (DELETE): Elimina el recurso especificando la entidad y el id en la URL.
<br>Cada operación usa una URL para identificar el recurso y un método HTTP que define la acción (por ejemplo, GET para leer o POST para crear), más el código de estado.<br><br>Para interactuar con una API REST, se emplean clientes REST, herramientas que facilitan la comunicación entre un cliente y un servidor RESTful mediante peticiones HTTP. Los clientes REST cumplen con los principios REST, proporcionando una interfaz simplificada para manejar los recursos y métodos HTTP (GET, POST, PUT, DELETE) y presentando una experiencia más amigable para el desarrollador.<br>Funcionamiento básico de un cliente REST:<br>
<br>Solicitud del cliente: Se envía una petición HTTP al servidor RESTful indicando el recurso y el método HTTP a utilizar.
<br>Procesamiento en el servidor: El servidor interpreta y procesa la solicitud, realiza la acción correspondiente y genera una respuesta.
<br>Respuesta del servidor: El servidor responde con el código de estado y los datos solicitados.
<br>Interpretación del cliente: El cliente interpreta la respuesta para verificar el resultado y procesa los datos si es necesario.
<br>Para probar APIs REST, una opción popular es Postman, que permite realizar peticiones HTTP mediante una interfaz intuitiva. Un ejemplo común es la API pública de Rick and Morty, donde el método GET permite obtener información sobre los personajes.<br>Para realizar peticiones como POST, PUT o DELETE, es necesario especificar los datos en formato JSON en el cuerpo de la solicitud. Sin embargo, muchas APIs públicas solo permiten el método GET para evitar modificaciones de datos.<br><br>JSON Server es una herramienta rápida y sencilla para crear APIs REST locales con datos en formato JSON. Es útil para el desarrollo y pruebas, ya que permite simular peticiones REST sin depender de servidores externos, facilitando el trabajo desde el front-end mientras el back-end aún está en desarrollo. Al finalizar el desarrollo, basta con cambiar las URLs locales por las de producción en el servidor real.<br>Instalación y Configuración Básica:<br>
<br>Se instala mediante npm install -g json-server, requiriendo tener Node.js.
<br>JSON Server usa un archivo db.json como base de datos simple en formato JSON, donde cada propiedad representa una entidad (similar a una tabla) y cada objeto dentro de los arrays representa un registro.
<br>Ejemplo de Inicio y Uso:<br>
<br>Iniciar el servidor con json-server --watch db.json, lo que habilita las rutas de la API en http://localhost:3000.
<br>Realizar peticiones como GET /posts/1 devuelve el registro correspondiente en formato JSON.
<br>Características Principales:<br>
<br>Soporta operaciones CRUD (GET, POST, PUT, PATCH, DELETE) y guarda automáticamente los cambios en db.json.
<br>Las peticiones deben incluir un Content-Type: application/json en su encabezado cuando envíen datos.
<br>Admite filtros en peticiones GET basadas en propiedades distintas de la id.
<br>Con JSON Server y Postman, es posible simular una API completa para pruebas, incluso realizar cambios en los datos, lo cual no es posible en la mayoría de las APIs públicas.]]></description><link>6-api-rest\api-rest.html</link><guid isPermaLink="false">6- API-REST/API REST.md</guid><pubDate>Sun, 10 Nov 2024 16:31:37 GMT</pubDate></item><item><title><![CDATA[COMUNICACIÓN ASÍNCRONA]]></title><description><![CDATA[ 
 <br><br>La programación&nbsp;asíncrona&nbsp;es una técnica que permite a tu programa iniciar una tarea de larga duración y seguir respondiendo a otros eventos mientras esa tarea se ejecuta, en lugar de tener que esperar hasta que esa tarea haya terminado. Una vez que dicha tarea ha finalizado, tu programa presenta el resultado.<br>La comunicación asíncrona ofrece varias ventajas en el desarrollo web, entre las que podemos destacar:<br>
<br>Mejora la experiencia de usuario
<br>Aumenta la escalabilidad
<br>Simplifica el código
<br>Sin embargo, presenta una serie de problemas:<br>
<br>Gestionar múltiples peticiones asíncronas puede llevarnos muchos problemas, al ser asíncrono cada petición acabará en un tiempo indeterminado y seguro que no acaban en el orden en que se lanzan.
<br>Podemos tener peticiones asíncronas que dependan de la finalización de otra.
<br>Podemos querer lanzar un conjunto de peticiones asíncronas y querer esperar a que todas hayan acabado para poder realizar acciones con todos los datos recibidos
<br>Se usa en una amplia variedad de aplicaciones web, como por ejemplo:<br>
<br>Carga de datos: Cuando un usuario carga una página web, se pueden cargar datos de forma asíncrona para evitar que la página se bloquee mientras se espera a que todos los datos estén disponibles.
<br>Peticiones a APIs REST: Las APIs REST se suelen consumir de forma asíncrona para obtener datos de servidores remotos.
<br>Chat en tiempo real: Las aplicaciones de chat en tiempo real utilizan la comunicación asíncrona para enviar y recibir mensajes de forma instantánea.
<br>Juegos online: Los juegos online necesitan una comunicación asíncrona para sincronizar las acciones de los jugadores en tiempo real.
<br>JavaScript ofrece actualmente varios mecanismos para la comunicación asíncrona:<br>
<br>
Callbacks: es una función que se pasa como argumento a otra función y se ejecuta después de que la función principal termina su tarea, generalmente asincrónica.

<br>
Promesas: es un objeto que representa un valor que puede estar disponible ahora, en el futuro, o nunca.

<br>
Async/await: async es una palabra clave que se usa para declarar una función asincrónica, mientras que await se utiliza para pausar la ejecución de una función async hasta que una promesa se resuelva.

<br>Pero, independientemente del mecanismo que utilicemos por debajo de él esta AJAX.<br><br>JavaScript Asíncrono + XML (AJAX) no es una tecnología por sí misma, es un término que describe un nuevo modo de utilizar conjuntamente varias tecnologías existentes. Esto incluye: HTML o XHTML, CSS, JavaScript, DOM, XML, XSLT, y lo más importante, el objeto XMLHttpRequest. <br>Cuando estas tecnologías se combinan en un modelo AJAX, es posible lograr aplicaciones web capaces de actualizarse continuamente sin tener que volver a cargar la página completa. Esto crea aplicaciones más rápidas y con mejor respuesta a las acciones del usuario.<br><img alt="classic-web-app-communication-model.jpg" src="7-comunicacion-asincrona\img\classic-web-app-communication-model.jpg"><br>XMLHttpRequest es un objeto de navegador incorporado que permite realizar solicitudes HTTP en JavaScript.<br><br>El funcionamiento básico del objeto XMLHttpRequest es el siguiente: <br>
<br>Crear el objeto: Crear objeto XMLHttpRequest.
<br>let xhr = new XMLHttpRequest();
<br>
<br>Inicializar el objeto: Configurar la solicitud.
<br>xhr.open(method, URL, [async, user, password])
<br>
<br>method método HTTP. Por lo general "GET" o "POST".
<br>URL la URL de la petición
<br>async si se establece explícitamente en false, entonces la solicitud es síncrona
<br>user, password inicio de sesión y contraseña para la autenticación HTTP básica (si es necesario).
<br>
<br>Enviar el objeto: Este método abre la conexión y envía la solicitud al servidor. GET y DELETE no tienen body, POST, PUT y PATCH si.
<br>xhr.send([body])
<br>
<br>
Esperar respuesta del servidor: Una vez enviada la petición el objeto XMLHttpRequest estará “escuchando” lo que va sucediendo con el estado de la petición, para ello utiliza los eventos del objeto xhr.

<br>load cuando se completa la solicitud (incluso si el estado HTTP es como 400 o 500), y la respuesta se descarga completamente.

xhr.onload = function() { 
	alert(`Loaded: ${xhr.status} ${xhr.response}`); 
};


<br>error cuando no se pudo realizar la solicitud, por ejemplo, red inactiva o URL no válida.

xhr.onerror = function() {
	alert(`Network Error`);	
};


<br>
Trabajar con la información recibida: Una vez que el servidor ha respondido, podemos recibir el resultado en las siguientes propiedades del objeto xhr:

<br>
status HTTP código de estado (un número): 200, 201, 404, 403 y así sucesivamente.

<br>
statusText Mensaje de estado HTTP (una cadena): generalmente OK para 200, Not Found para 404, Forbidden para, 403 etc.

<br>
response La respuesta del servidor, aquí es donde estará la información que nos manda el servidor. Existen diferentes formatos de respuesta del servidor. Podemos usar la propiedad xhr.responseType para establecer el formato de respuesta:

<br>"" (predeterminado): obtener como cadena 
<br>"text" llega como string
<br>"arraybuffer" llega como ArrayBuffer para datos binarios
<br>"blob" usado para datos binarios 
<br>"document" llega como documento XML (puede usar XPath y otros métodos XML), 
<br>"json" llega como JSON (analizado automáticamente). (ES EL HABITUAL)




<br>Una petición completa quedaría de la siguiente forma:<br>let xhr = new XMLHttpRequest();
xhr.open(method, URL, [async, user, password])
xhr.responseType = 'json';
xhr.send([body])

xhr.onload = function() {
	alert(`Loaded: ${xhr.status} ${xhr.response}`);
};

//Error en petición
xhr.onerror = function() {
	alert(`Network Error`);
};
<br><br>Se utiliza para solicitar datos de una API sin enviar información adicional al servidor.<br>const xhr = new XMLHttpRequest();
xhr.open("GET", "https://rickandmortyapi.com/api/character");

xhr.onload = function() {
    if (xhr.status == 200) {
        const personajes = JSON.parse(xhr.responseText);
        console.log(personajes);
    }
};
xhr.send();
<br><br>Se utiliza para eliminar un registro en el servidor.<br>const url = "http://localhost:3000/articulos";

function deleteArticulo() {
    let id = prompt("Dime el id del articulo...");
    const xhr = new XMLHttpRequest();
    
    xhr.open("DELETE", `${url}/${id}`);
    
    xhr.onload = function() {
        if (xhr.status == 200) {
            console.log("El articulo se ha borrado");
        } else {
            console.log("ERROR. El articulo NO se ha borrado");
        }
    };
    
    xhr.send();
}
<br><br>
<br>POST: Se utiliza para crear un nuevo registro en el servidor.
<br>const url = "http://localhost:3000/articulos";  
  
function postArticulo() {  
    let id = prompt("Dime el id del articulo...");  
    let nombre = prompt("Dime el nombre del articulo...");  
    let precio = parseInt(prompt("Dime el precio del articulo..."));  
    let articulo = JSON.stringify({"id": id, "nombre": nombre, "precio": precio});  
    const xhr = new XMLHttpRequest();  
    xhr.open("POST", url);  
    xhr.setRequestHeader('Content-Type', 'application/json; charset=utf-8');  
    xhr.send(articulo);  
    
    xhr.onload = function () {  
        if (xhr.status == 201) {  
            console.log("El articulo se ha insertado.");  
        } else {  
            console.log("ERROR. El articulo NO se ha insertado.");  
        }  
    };  
}
<br>
<br>PUT: Se utiliza para modificar un registro existente en el servidor.
<br>const url = "http://localhost:3000/articulos";  
  
function putArticulo() {  
    let id = prompt("Dime el id del articulo a modificar...");  
    let nombre = prompt("Dime el nuevo nombre del articulo...");  
    let precio = parseInt(prompt("Dime el nuevo precio del articulo..."));  
    let articulo = JSON.stringify({"id": id, "nombre": nombre, "precio": precio});  
    const xhr = new XMLHttpRequest();  
    xhr.open("PUT", `${url}/${id}`);  
    xhr.setRequestHeader('Content-Type', 'application/json; charset=utf-8');  
    xhr.send(articulo);  
    
    xhr.onload = function () {  
        if (xhr.status == 200) {  
            console.log("El articulo ha sido modificado.");  
        } else {  
            console.log("ERROR. El articulo NO se ha modificado.");  
        }  
    };  
}
<br><br>Usar XMLHttpRequest implica gestionar peticiones asíncronas mediante callbacks. En peticiones simples no hay ningún problema, pero si queremos hacer algo más complejo y necesitamos hacer peticiones anidadas, donde cada petición depende del resultado de la anterior, el código se vuelve complejo y difícil de mantener, dando lugar al "callback hell" o "pyramid of doom".<br><br>Pongamos un ejemplo:<br> Si queremos obtener el precio de un artículo vendido por un proveedor, primero hacemos una petición GET para el proveedor y luego otra para el artículo.<br>Debido a la asincronía, la segunda petición debe lanzarse en el onload de la primera, lo que complica el código cuando hay varias peticiones en secuencia.<br><br>Para solucionar esto, ECMAScript 6 (ES6) introdujo las promesas para facilitar la gestión de código asíncrono.<br>Una promesa es un objeto que representa el resultado de una operación asíncrona (éxito o fracaso).<br>Las CARACTERÍSTICAS principales de las promesas son:<br>
<br>Asíncrona: No bloquea la ejecución del código.
<br>Finalización: La promesa puede cumplirse (resolve) o rechazarse (reject). Un resolve indica éxito y un reject, error.
<br>Sus VENTAJAS son:<br>
<br>Simplifican el manejo de código asíncrono en operaciones que requieren esperar, como las peticiones a servidores.
<br>Permiten encadenar operaciones asíncronas en secuencia.
<br>Mejoran la legibilidad del código frente a los callbacks tradicionales.
<br>Además tiene varios ESTADOS:<br>
<br>Pendiente: Estado inicial.
<br>Resuelta: Promesa completada exitosamente.
<br>Rechazada: Promesa fallida.
<br>Al lanzarse, la promesa está en estado "pendiente". Si se cumple, pasa a "resuelta" y se gestiona con .then(). Si falla, pasa a "rechazada" y se gestiona con .catch().<br><br>Es el método que nos permite gestionar la finalización de una forma correcta de la promesa.<br>promise.then( function(result) { /* gestión resultados */ }) // NO HABITUAL
promise.then( result =&gt; { /* gestión resultados */ }) // HABITUAL
<br><br>Es el método que nos permite gestionar la finalización con error de la promesa.<br>promise.catch( function(error) { /* gestión error */ }) // NO HABITUAL
promise.catch( error =&gt; { /* gestión error */ }) // HABITUAL
<br><br>Fetch es una API de JavaScript para realizar peticiones HTTP de forma asíncrona. Es el nuevo estándar en JavaScript para hacer peticiones web y reemplaza al objeto XMLHttpRequest.<br>Representa una serie de VENTAJAS:<br>
<br>Sencillez: Su interfaz es fácil de usar, lo que hace que el código sea más claro y mantenible.
<br>Promesas: Usa promesas, lo que permite manejar el éxito o el error de una petición de manera elegante.
<br>Flexibilidad: Soporta diferentes métodos HTTP (GET, POST, PUT, DELETE, etc.), y permite personalizar encabezados y cuerpos de las peticiones.
<br>Fetch se encarga de crear, configurar y enviar la petición HTTP y devuelve el resultado en una promesa. Los resultados se gestionan con los métodos .then() para el éxito y .catch() para el error, el cual se puede omitir ya que se usa solo cuando Fetch no puede realizar una solicitud a la API, como por ejemplo si no hay conexión de red o no se encuentra la URL..<br>La función fetch() acepta dos parámetros:<br>
<br>URL: La URL a la que se envía la petición (obligatorio).
<br>Opciones: Configuración adicional de la petición, como el método HTTP (opcional).
<br>fetch('url', {})
	.then(response =&gt; {
		// Gestionamos la respuesta de la petición aqui
	})
	.catch(error =&gt; {
		// Si hay un error de red lo gestionamos aqui
	});
<br><br>Realiza una petición GET a la URL proporcionada y gestiona el resultado.<br>let url = 'http://localhost:3000/articulos';
fetch(url)
	.then(response =&gt; response.json()) // Convierte la respuesta a JSON
    .then(articulos =&gt; console.log(articulos)) // Muestra los datos
    .catch(error =&gt; console.log("Network error"));
<br>
<br>
Descripción del objeto Response:

<br>status: Código HTTP (e.g., 200: éxito, 404: no encontrado).
<br>statusText: Texto del estado HTTP (e.g., "OK", "Not Found").
<br>headers: Encabezados de la respuesta.
<br>body: Cuerpo de la respuesta, que puede ser texto, JSON, blob, etc.
<br>ok: Booleano que indica si la petición fue exitosa.


<br>
Control de errores:

<br>let url = 'http://localhost:3000/articulos/5';
fetch(url)
    .then(response =&gt; {
        if (!response.ok) {
            throw new Error(`Error ${response.status} ${response.statusText}`);
        }
        return response.json();
    })
    .then(articulo =&gt; console.log(articulo))
    .catch(error =&gt; alert(error));
<br><br> Elimina un recurso específico usando DELETE, indicando el ID del recurso en la URL.<br>let url = 'http://localhost:3000/articulos/2';
fetch(url, { method: 'DELETE' })
    .then(response =&gt; {
       if (!response.ok) {
            throw new Error(`Error ${response.status} ${response.statusText}`);
        }
       return response.json(); // Normalmente devuelve un objeto vacío
   })
	.then(data =&gt; console.log("Artículo eliminado:", data))
	.catch(error =&gt; alert(error));
<br><br>
<br>
POST: Inserta un nuevo recurso.
Configura el encabezado Content-Type y convierte el objeto en cadena JSON usando JSON.stringify.

<br>let url = 'http://localhost:3000/articulos';
let id = prompt("Dime el id: ");
let nombre = prompt("Dime el nombre: ");
let precio = parseInt(prompt("Dime el precio: "));
let articuloNuevo = JSON.stringify({ "id": id, "nombre": nombre, "precio": precio });

let opciones = {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: articuloNuevo
};

fetch(url, opciones)
    .then(response =&gt; {
        if (!response.ok) {
            throw new Error(`Error ${response.status} ${response.statusText}`);
        }
        return response.json();
    })
    .then(articulo =&gt; console.log("Artículo insertado:", articulo))
    .catch(error =&gt; alert(error));
<br>PUT: Modifica un recurso existente.<br>let url = 'http://localhost:3000/articulos';
let id = prompt("Dime el id del registro a modificar: ");
let nombre = prompt("Dime el nuevo nombre: ");
let precio = parseInt(prompt("Dime el nuevo precio: "));
let articuloMod = JSON.stringify({ "id": id, "nombre": nombre, "precio": precio });

let opciones = {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: articuloMod
};

fetch(`${url}/${id}`, opciones)
    .then(response =&gt; {
        if (!response.ok) {
            throw new Error(`Error ${response.status} ${response.statusText}`);
        }
        return response.json();
    })
    .then(articulo =&gt; console.log("Artículo modificado:", articulo))
    .catch(error =&gt; alert(error));
<br><br><br>Para realizar peticiones dependientes en secuencia, usamos el encadenamiento de promesas para evitar "callback hell". Primero, se realiza una petición fetch para obtener datos de un proveedor, y una vez obtenidos, con el idArticulo de ese proveedor, se realiza una segunda petición para obtener datos de un artículo específico. El encadenamiento permite manejar el flujo de peticiones en un código más limpio, ya que cada .then() devuelve una promesa al siguiente, y un solo .catch() gestiona todos los errores.<br>let url = 'http://localhost:3000/';
let idProveedor = prompt("Dime el id del proveedor: ");

fetch(url + "proveedores/" + idProveedor)
    .then(response =&gt; {
        if (!response.ok) throw new Error(`Error proveedor ${response.status}: ${response.statusText}`);
        return response.json();
    })
    .then(p =&gt; {
        console.log(p);
        return fetch(url + "articulos/" + p.idArticulo);
    })
    .then(response =&gt; {
        if (!response.ok) throw new Error(`Error artículo ${response.status}: ${response.statusText}`);
        return response.json();
    })
    .then(a =&gt; console.log(a))
    .catch(error =&gt; alert(error));
<br><br>Para mejorar la reutilización, se encapsulan las peticiones fetch en funciones que retornan una promesa. Así, podemos hacer peticiones repetidas sin duplicar código, simplemente llamando a funciones con los parámetros necesarios. Ejemplo: getArticulo() para obtener un artículo, y getProveedor() para obtener un proveedor.<br>function getArticulo(id) {
    return fetch(url + "articulos/" + id)
        .then(response =&gt; {
            if (!response.ok) throw new Error(`Error en artículo ${response.status}: ${response.statusText}`);
            return response.json();
        });
}

function getProveedor(id) {
    return fetch(url + "proveedores/" + id)
        .then(response =&gt; {
            if (!response.ok) throw new Error(`Error en proveedor ${response.status}: ${response.statusText}`);
            return response.json();
        });
}

// Uso de las funciones
getProveedor(1)
    .then(p =&gt; {
        console.log(p);
        return getArticulo(p.idArticulo);
    })
    .then(a =&gt; console.log(a))
    .catch(error =&gt; alert(error));
<br><br>Se puede simplificar aún más creando una función genérica getEntidad que recibe como parámetros el tipo de entidad y el id. Esto permite obtener datos de cualquier entidad con una sola función.<br>function getEntidad(entidad, id) {
    return fetch(url + entidad + "/" + id)
        .then(response =&gt; {
            if (!response.ok) throw new Error(`Error en ${entidad} con id ${id}: ${response.statusText}`);
            return response.json();
        });
}

// Ejemplo de uso
getEntidad("proveedores", 1)
    .then(p =&gt; {
        console.log(p);
        return getEntidad("articulos", p.idArticulo);
    })
    .then(a =&gt; console.log(a))
    .catch(error =&gt; alert(error));
<br>Con esta estructura, el código es más modular y fácil de leer, además de ser adaptable para futuras modificaciones y ampliaciones.<br><br>async/await es una forma simplificada de manejar promesas, que permite escribir código asíncrono de forma más secuencial. Algunos aspectos clave de async/await son:<br>
<br>
No se utiliza .then() para manejar el resultado de las promesas, sino que se espera directamente con await.

<br>
No se dispone de un manejador .catch(), sino que los errores se gestionan con un bloque try/catch.

<br>
Cambia el modelo de ejecución de no bloqueante a bloqueante, ya que await detiene la ejecución hasta que se resuelve la promesa.

<br>Para obtener todos los artículos, el código podría verse así, aunque debe estar dentro de una función async para que await funcione.<br>let url = 'http://localhost:3000/articulos';

async function getArticulos() {
    const response = await fetch(url);
    const articulos = await response.json();
    console.log(articulos);
}
<br>Si queremos acceder a un artículo en concreto, podemos definir una función async que recibe un id como parámetro. Este código necesita gestionar errores, como un artículo no encontrado (404), para lo cual usamos un bloque try/catch.<br>async function getArticulo(id) {
    try {
        const response = await fetch(url + "/" + id);
        if (!response.ok) throw new Error(`Error en artículo con id ${id}`);
        const articulo = await response.json();
        console.log(articulo);
    } catch (error) {
        console.log(error);
    }
}
<br><br>Para realizar una secuencia de peticiones donde primero obtenemos los datos de un proveedor y luego usamos el idArticulo del proveedor para obtener el artículo correspondiente, podemos utilizar async/await con un manejo de errores centralizado en try/catch.<br>async function getArticuloProveedor() {
    let url = 'http://localhost:3000/';
    let idProveedor = prompt("Dime el id del proveedor: ");

    try {
        // Petición para obtener el proveedor
        let response = await fetch(url + "proveedores/" + idProveedor);
        if (!response.ok) throw new Error(`Error en proveedor con id ${idProveedor}`);
        let proveedor = await response.json();

        // Petición para obtener el artículo del proveedor
        response = await fetch(url + "articulos/" + proveedor.idArticulo);
        if (!response.ok) throw new Error(`Error en artículo con id ${proveedor.idArticulo}`);
        let articulo = await response.json();

        console.log(articulo);
    } catch (error) {
        console.log(error);
    }
}
<br>
<br>
Primera Petición (Proveedor): Realiza una solicitud fetch para obtener los datos de un proveedor. Si no se obtiene una respuesta satisfactoria (ok), se lanza un error.

<br>
Segunda Petición (Artículo): Con el idArticulo del proveedor obtenido en la primera solicitud, se realiza una segunda petición fetch para obtener los datos del artículo correspondiente.

<br>
Manejo de Errores con try/catch: Cualquier error en las peticiones, como respuestas no válidas, se gestiona en el bloque catch.

]]></description><link>7-comunicacion-asincrona\comunicación-asincrona.html</link><guid isPermaLink="false">7- Comunicacion Asincrona/Comunicación Asincrona.md</guid><pubDate>Thu, 14 Nov 2024 15:13:07 GMT</pubDate><enclosure url="7-comunicacion-asincrona\img\classic-web-app-communication-model.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="7-comunicacion-asincrona\img\classic-web-app-communication-model.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ÍNDICE DESARROLLO WEB EN ENTORNO EN CLIENTE]]></title><description><![CDATA[ 
 <br><br><br>
<br><a class="internal-link" data-href=".//0- Introduccion/Arquitecturas y tecnologías  - programación Web en cliente.md" href="0-introduccion\arquitecturas-y-tecnologías-programación-web-en-cliente.html" target="_self" rel="noopener nofollow">Arquitecturas y tecnologías - programación Web en cliente</a>
<br><br>
<br><a class="internal-link" data-href="./1- Sintaxis/Sintaxis del lenguaje.md" href="1-sintaxis\sintaxis-del-lenguaje.html" target="_self" rel="noopener nofollow">Sintaxis del lenguaje</a>
<br><br>
<br><a class="internal-link" data-href="./2- Objetos Predefinidos/Objetos predifinidos.md" href="2-objetos-predefinidos\objetos-predifinidos.html" target="_self" rel="noopener nofollow">Objetos predefinidos</a> 
<br><br>
<br><a class="internal-link" data-href="./3- Eventos/Eventos.md" href="3-eventos\eventos.html" target="_self" rel="noopener nofollow">Eventos</a>
<br><br>
<br><a class="internal-link" data-href="./4- DOM/DOM.md" href="4-dom\dom.html" target="_self" rel="noopener nofollow">DOM</a>
<br><br>
<br><a class="internal-link" data-href="./5- Formularios/Formularios.md" href="5-formularios\formularios.html" target="_self" rel="noopener nofollow">Formularios</a>
<br><br>
<br><a class="internal-link" data-href="./6- API-REST/API REST.md" href="6-api-rest\api-rest.html" target="_self" rel="noopener nofollow">API REST</a>
<br><br>
<br><a class="internal-link" data-href="./7- Comunicacion Asincrona/Comunicación Asincrona.md" href="7-comunicacion-asincrona\comunicación-asincrona.html" target="_self" rel="noopener nofollow">Comunicación asíncronatos</a>
<br><br>
<br><a class="internal-link" data-href="JS CheatSheet.md" href="js-cheatsheet.html" target="_self" rel="noopener nofollow">Resumen</a>
]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Fri, 15 Nov 2024 08:51:22 GMT</pubDate></item><item><title><![CDATA[Módulos]]></title><description><![CDATA[ 
 <br><br>Los módulos permiten exportar e importar código y/o datos entre diferentes archivos de JavaScript, promoviendo organización y reutilización.<br>// Exportar un elemento: permite usarlo en otros archivos
export const articulos = [
	{id:1, nombre:"articulo1"},
	{id:2, nombre:"articulo2"},
	{id:3, nombre:"articulo3"}
];

// Importar un elemento desde otro archivo
import {articulos} from "./datos.js";

// Uso en HTML: el atributo "type=module" permite usar módulos en JavaScript
&lt;script src="./js/main.js" type="module"&gt;&lt;/script&gt;
<br><br>Los módulos tienen un ámbito propio y a veces el HTML no puede acceder a sus variables directamente. El DOM permite interactuar con esos elementos.<br>// Accede al botón en el DOM y agrega un listener que ejecuta una función al hacer clic
document.getElementById("btn").addEventListener("click", verMensaje);
<br><br><br><br>var persona = "pedro"; // variable de alcance global
let persona = "pedro"; // variable de alcance en bloque
const persona = "pedro"; // variable definida como constante, tras sun inicialización no se puede modificar
<br><br>// IMPLÍCITAS -&gt; automáticamente
let numero = 10; 
let texto = "5"; 
let suma = numero + texto; // "105" (convierte número a string)

// EXPLÍCITAS -&gt; forzando
let texto = "10";
let numero = Number(texto); // Convierte a número
console.log(numero); // 10
<br><br><br>// Realizan operaciones matemáticas básicas.
let suma = 5 + 2; // suma = 7 
let resto = 10 % 3; // resto = 1
<br><br>// Comparan valores y devuelven `true` o `false`.
let igualdad = (a == b); // true si a es igual a b
<br><br>// Realizan operaciones lógicas `AND` = &amp;&amp;, `OR` = || y `NOT` = !.
let and = (a &amp;&amp; b); // true si ambos son true
<br><br>// Permiten asignar y actualizar valores en una variable.
let a = 5; a += 2; // equivale a: a = a + 2
<br><br>// El operador `typeof` permite verificar el tipo de dato de una variable.
console.log(typeof "string"); // "string"
console.log(typeof 10); // "number"
console.log(typeof true); // "boolean"
// object // undefined // symbol // function
<br><br><br>if (condicion) {
 // Código a ejecutar si la condición es verdadera
} else {
 // Código a ejecutar si la condición es falsa
}
<br><br>switch (expresion) {
	case valor1:
		 // Código a ejecutar si la expresión es igual a valor1
		 break;
	 case valor2:
		 // Código a ejecutar si la expresión es igual a valor2
		 break;
	 default:
		 // Código a ejecutar si la expresión no coincide con ningún caso
}
<br><br>let resultado = (condicion) ? true : false;
// true = si se cumple
// false = si no se cumple
<br><br><br>// ejecuta un bloque de código un número específico de veces
for (let i = 0; i &lt; 10; i++) {
 // Código a ejecutar 10 veces
}

// ### PROGRAMACIÓN FUNCIONAL ###
Array.from({ length: 10 }).forEach((_, i) =&gt; {
  // Código a ejecutar 10 veces
  console.log(`Iteración ${i + 1}`);
});
<br><br>// Recorre las propiedades de un objeto.
let persona = { nombre: "Juan", edad: 30, profesion: "Desarrollador" };

for (let propiedad in persona) {
 console.log(`${propiedad}: ${persona[propiedad]}`);
}

// ### PROGRAMACIÓN FUNCIONAL ###
const persona = { nombre: "Juan", edad: 30, profesion: "Desarrollador" };

Object.entries(persona).forEach(([propiedad, valor]) =&gt; {
  console.log(`${propiedad}: ${valor}`);
});
<br><br>// Recorre los valores de un array o cadena de texto (iterable).
let numeros = [10, 20, 30];

for (let numero of numeros) {
 console.log(numero);
}

// ### PROGRAMACIÓN FUNCIONAL ###
const numeros = [10, 20, 30];

numeros.forEach(numero =&gt; console.log(numero));
<br><br>// ejecuta X mientras una condición se cumpla
let i = 0;

while (i &lt; 10) {
 // Código a ejecutar mientras i sea menor que 10
 i++;
}

// ### PROGRAMACIÓN FUNCIONAL ###
const repetirHasta = (condicion, accion, i = 0) =&gt; {
  if (!condicion(i)) return;
  accion(i);
  repetirHasta(condicion, accion, i + 1);
};

// Ejemplo de uso:
repetirHasta(i =&gt; i &lt; 10, i =&gt; console.log(`Iteración ${i + 1}`));
<br><br>// ejecuta X 1 vez, luego comprueba si se cumple y mientras sea así hace X
let i = 0;

do {
 // Código a ejecutar al menos una vez
 i++;
} while (i &lt; 10);

// ### PROGRAMACIÓN FUNCIONAL ###
const repetirAlMenosUnaVez = (condicion, accion, i = 0) =&gt; {
  accion(i);
  if (!condicion(i)) return;
  repetirAlMenosUnaVez(condicion, accion, i + 1);
};

// Ejemplo de uso:
repetirAlMenosUnaVez(i =&gt; i &lt; 10, i =&gt; console.log(`Iteración ${i + 1}`));
<br><br><br><br>representa la ventana del navegador y proporciona acceso a sus propiedades y métodos<br><br>// 1. location: Proporciona información sobre la URL actual de la página web y permite redirigir a otras páginas.
console.log(window.location.href); // Imprime la URL actual
window.location.href = "https://www.example.com"; // Redirige a otra página

// 2. document: Representa el documento HTML de la página web, proporcionando acceso a sus elementos y métodos (DOM - Document Object Model).
let titulo = document.getElementById("tituloPagina");
titulo.textContent = "Nuevo título de la página"; // Cambia el texto del título

// 3. history: Proporciona acceso al historial del navegador, permitiendo navegar entre las páginas visitadas.
window.history.back(); // Navega a la página anterior
window.history.go(2);  // Navega dos páginas hacia atrás

// 4. screen: Proporciona información sobre las dimensiones de la pantalla, como la resolución.
let anchoPantalla = window.screen.width;
console.log(`Ancho de la pantalla: ${anchoPantalla} pixeles`); // Imprime el ancho de pantalla

// 5. navigator: Proporciona información sobre el navegador utilizado, como el nombre, la versión y el sistema operativo.
let navegador = window.navigator.userAgent;
console.log(`Navegador: ${navegador}`); // Imprime la información del navegador
<br><br>// 1. alert(): Muestra un cuadro de diálogo emergente con un mensaje y un botón de "Aceptar".
window.alert("¡Hola, mundo!"); // Muestra una alerta al usuario

// 2. prompt(): Muestra un cuadro de diálogo emergente para obtener información del usuario.
let nombre = window.prompt("Dime un nombre:");
console.log("Nombre:", nombre); // Imprime el nombre introducido o `null` si se canceló

// 3. confirm(): Muestra un cuadro de diálogo emergente para confirmar una acción, con "Aceptar" y "Cancelar".
let confirmar = window.confirm("¿Desea continuar?");
if (confirmar) {
	console.log("Usuario confirmó la acción");
} else {
	console.log("Usuario canceló la acción");
}

// 4. open(): Abre una nueva ventana del navegador con la URL especificada.
window.open("https://www.example.com", "_blank"); // Abre en una nueva pestaña

// 5. close(): Cierra la ventana actual o una ventana abierta con open.
window.close(); // Cierra la ventana actual (si fue abierta mediante JavaScript)
<br><br><br>let nombre = "Juan";
let saludo = `Hola, ${nombre}`;
console.log(saludo); // Imprime "Hola, Juan"

let nombre = new String(‘Juan’); // a través de constructor
<br><br>// 1. length: Devuelve la longitud de la cadena
let frase = "JavaScript es un lenguaje de programación";
console.log(`Longitud de la frase: ${frase.length}`);
<br><br>// 1. charAt(índice): Devuelve el carácter en la posición especificada por el índice.
let texto = "ABCDEFGHIJKLMN";
console.log(texto.charAt(5)); // Imprime "F" (carácter en la posición 5)

// 2. charCodeAt(índice): Devuelve el código Unicode del carácter en la posición especificada por el índice.
let letra = "ñ";
console.log(letra.charCodeAt(0)); // Imprime "165" (código Unicode de la letra "ñ")

// 3. indexOf(subcadena, inicio): Busca la primera aparición de una subcadena, devolviendo la posición de inicio.
let frase = "Esta frase contiene la palabra programación";
let indice = frase.indexOf("programación");
if (indice !== -1) {
  console.log(`programación está en la posición: ${indice}`);
} else {
  console.log("programación no se encuentra en la frase");
}

// 4. lastIndexOf(subcadena, inicio): Busca la última aparición de una subcadena, devolviendo la posición de inicio.
let texto2 = "Repetir la palabra palabra";
console.log(texto2.lastIndexOf("palabra")); // Imprime la posición de la última aparición de "palabra"

// 5. replace(subcadena, reemplazo): Reemplaza todas las apariciones de una subcadena por una cadena de reemplazo.
let texto3 = "Hola a todos, soy un robot";
let textoReemplazado = texto3.replace("robot", "humano");
console.log(textoReemplazado); // Imprime "Hola a todos, soy un humano"

// 6. toUpperCase() y toLowerCase(): Convierten la cadena a mayúsculas y minúsculas.
let saludo = "Hola Mundo";
console.log(saludo.toUpperCase()); // Imprime "HOLA MUNDO"
console.log(saludo.toLowerCase()); // Imprime "hola mundo"

// 7. trim(): Elimina los espacios en blanco al inicio y al final de la cadena.
let texto4 = "   Hola Mundo   ";
console.log(texto4.trim()); // Imprime "Hola Mundo"

// 8. concat(cadena2, ...): Concatena dos o más cadenas.
let nombre = "Juan";
let apellido = "Pérez";
let nombreCompleto = nombre.concat(" ", apellido);
console.log(nombreCompleto); // Imprime "Juan Pérez"

// 9. slice(inicio, fin): Extrae una subcadena desde una posición inicial hasta una posición final especificada.
let frase2 = "JavaScript es un lenguaje de programación";
let subcadena = frase2.slice(10, 25);
console.log(subcadena); // Imprime "es un lenguaje"

// 10. split(): Divide una cadena de texto en una lista de subcadenas, basado en un separador especificado.

	// Ejemplo 1: Dividir una cadena por espacios
	let frase3 = "Esta frase se divide por espacios";
	let palabras = frase3.split(" ");
	console.log(palabras); // Imprime ["Esta", "frase", "se", "divide", "por", "espacios"]

	// Ejemplo 2: Dividir una cadena por comas
	let lista = "rojo,verde,azul,amarillo";
	let colores = lista.split(",");
	console.log(colores); // Imprime ["rojo", "verde", "azul", "amarillo"]

	// Ejemplo 3: Dividir una cadena con un límite especificado
	let cadenaLarga = "Lorem ipsum dolor sit amet, consectetur adipiscing elit";
	let partes = cadenaLarga.split(" ", 5); // Límite de 5 subcadenas
	console.log(partes); // Imprime las primeras 5 palabras de la cadena

// Ejemplo 4: Obtener caracteres individuales
	let texto5 = "Hola, mundo!";
	let caracteres = texto5.split("");
	console.log(caracteres); // Imprime un array con cada carácter: ["H", "o", "l", "a", ",", " ", "m", "u", "n", "d", "o", "!"]
<br><br><br>// Sin argumentos
let fechaActual = new Date();
console.log(fechaActual);

// con argumentos
let fechaEspecifica = new Date(2024, 5, 12, 10, 30, 15, 500);
console.log(fechaEspecifica);

// con cadena de fecha
let fechaCadena = "2024-06-12T10:30:15.500+02:00";
let fechaObjeto = new Date(fechaCadena);
console.log(fechaObjeto);
<br><br>// 1. getFullYear(): Obtiene el año de la fecha como un número entero de cuatro dígitos.
let fecha = new Date();
let año = fecha.getFullYear();
console.log(`Año actual: ${año}`); // Ejemplo: 2024

// 2. getMonth(): Obtiene el mes de la fecha como un número entero de 0 a 11, donde 0 representa enero y 11 diciembre.
let mes = fecha.getMonth();
console.log(`Mes actual: ${mes + 1}`); // Ejemplo: 6 (junio)

// 3. getDate(): Obtiene el día del mes de la fecha como un número entero de 1 a 31.
let dia = fecha.getDate();
console.log(`Día actual: ${dia}`); // Ejemplo: 12

// 4. getHours(): Obtiene la hora de la fecha como un número entero de 0 a 23.
let hora = fecha.getHours();
console.log(`Hora actual: ${hora}`); // Ejemplo: 13

// 5. getMinutes(): Obtiene los minutos de la fecha como un número entero de 0 a 59.
let minutos = fecha.getMinutes();
console.log(`Minutos actuales: ${minutos}`); // Ejemplo: 26

// 6. getSeconds(): Obtiene los segundos de la fecha como un número entero de 0 a 59.
let segundos = fecha.getSeconds();
console.log(`Segundos actuales: ${segundos}`); // Ejemplo: 12

// 7. getMilliseconds(): Obtiene los milisegundos de la fecha como un número entero de 0 a 999.
let milisegundos = fecha.getMilliseconds();
console.log(`Milisegundos actuales: ${milisegundos}`);
<br><br>// 1. setFullYear(año): Establece el año de la fecha en el valor entero especificado.
let fecha = new Date();
fecha.setFullYear(2023); // Establece el año a 2023
console.log(fecha.getFullYear()); // Imprime: 2023

// 2. setMonth(mes): Establece el mes de la fecha en el valor especificado (de 0 a 11, donde 0 representa enero y 11 diciembre).
fecha.setMonth(4); // Establece el mes a mayo (mes 4)
console.log(fecha.getMonth() + 1); // Imprime: 5 (mayo)

// 3. setDate(día): Establece el día del mes de la fecha en el valor entero especificado (de 1 a 31).
fecha.setDate(10); // Establece el día a 10
console.log(fecha.getDate()); // Imprime: 10

// 4. setHours(hora): Establece la hora de la fecha en el valor entero especificado (de 0 a 23).
fecha.setHours(18); // Establece la hora a 18
console.log(fecha.getHours()); // Imprime: 18

// 5. setMinutes(minutos): Establece los minutos de la fecha en el valor entero especificado (de 0 a 59).
fecha.setMinutes(30); // Establece los minutos a 30
console.log(fecha.getMinutes()); // Imprime: 30

// 6. setSeconds(segundos): Establece los segundos de la fecha en el valor entero especificado (de 0 a 59).
fecha.setSeconds(15); // Establece los segundos a 15
console.log(fecha.getSeconds()); // Imprime: 15

// 7. setMilliseconds(milisegundos): Establece los milisegundos de la fecha en el valor entero especificado (de 0 a 999).
fecha.setMilliseconds(500); // Establece los milisegundos a 500
console.log(fecha.getMilliseconds()); // Imprime: 500
<br><br><br>console.log(Number.MAX_VALUE); // Valor numérico más grande posible 
console.log(Number.MIN_VALUE); // Valor numérico más pequeño posible 
console.log(Number.POSITIVE_INFINITY); // Infinito positivo 
console.log(Number.NEGATIVE_INFINITY); // Infinito negativo 
console.log(Number.NaN); // Valor no numérico ("Not a Number")
<br><br>const numero = 123.4567;
console.log(numero.toString()); // Convierte a cadena de texto
console.log(numero.toFixed(2)); // "123.46" - Convierte a texto con 2 decimales
console.log(numero.toExponential(2)); // Notación exponencial: "1.23e+2"
console.log(numero.valueOf()); // Valor primitivo del número

// Métodos de comprobación:
console.log(Number.isFinite(numero)); // true - Comprueba si es finito
console.log(Number.isNaN('Hola')); // true - Comprueba si es NaN
console.log(Number.isInteger(numero)); // false - Comprueba si es un entero

// Convertir cadena a número:
const cadena = '100';
const numeroConvertido = Number(cadena);
console.log(numeroConvertido); // 100

// Crear un objeto Number con el constructor
const nuevoNumero = new Number(200);
console.log(nuevoNumero); // Imprime: Number {valueOf: 200}
<br><br>// Constantes de Math:
console.log(Math.PI); // Valor de pi (aproximadamente 3.14159)
console.log(Math.E); // Número de Euler (aproximadamente 2.71828)
console.log(Math.LN2); // Logaritmo natural de 2
console.log(Math.LN10); // Logaritmo natural de 10
console.log(Math.SQRT2); // Raíz cuadrada de 2
console.log(Math.SQRT1_2); // Raíz cuadrada de 1/2

// Funciones aritméticas:
console.log(Math.abs(-5)); // Valor absoluto: 5
console.log(Math.pow(2, 3)); // Potencia: 2^3 = 8
console.log(Math.sqrt(16)); // Raíz cuadrada: 4
console.log(Math.floor(4.7)); // Redondea hacia abajo: 4
console.log(Math.ceil(4.3)); // Redondea hacia arriba: 5
console.log(Math.round(4.5)); // Redondea al más cercano: 5
console.log(Math.random()); // Genera un número aleatorio entre 0 y 1

// Funciones trigonométricas:
console.log(Math.sin(Math.PI / 2)); // Seno de π/2: 1
console.log(Math.cos(Math.PI)); // Coseno de π: -1
console.log(Math.tan(0)); // Tangente de 0: 0
console.log(Math.asin(1)); // Arcoseno de 1: π/2
console.log(Math.acos(0)); // Arcocoseno de 0: π/2
console.log(Math.atan(1)); // Arcotangente de 1: π/4
console.log(Math.atan2(1, 1)); // Arcotangente de 1/1: π/4

// Funciones de logaritmos:
console.log(Math.log(10)); // Logaritmo natural de 10
console.log(Math.log10(100)); // Logaritmo base 10 de 100: 2
console.log(Math.log2(8)); // Logaritmo base 2 de 8: 3
console.log(Math.exp(1)); // Exponencial de 1 (e^1): Math.E

// Funciones de redondeo:
console.log(Math.round(4.5)); // Redondea al más cercano: 5
console.log(Math.floor(4.7)); // Redondea hacia abajo: 4
console.log(Math.ceil(4.3)); // Redondea hacia arriba: 5

// Funciones de mínimo y máximo:
console.log(Math.max(1, 3, 2)); // Máximo: 3
console.log(Math.min(1, 3, 2)); // Mínimo: 1
<br><br><br>// Crear cookies
document.cookie = "nombre=Pepe";
document.cookie = "edad=30";
document.cookie = "ciudad=Valencia";
alert("Cookies guardadas correctamente.");
console.log(document.cookie); // Mostrar todas las cookies

// Configuración de propiedades importantes
// 1. path: Accesibilidad de la cookie en todas las páginas
document.cookie = "ciudad=Valencia; path=/";

// 2. expires y max-age: Controlan la duración de la cookie
// Expira cuando el navegador se cierra si no se establece
// Explicación de expires
let date = new Date(Date.now() + 86400e3); // +1 día
document.cookie = "ciudad=Valencia; expires=" + date.toUTCString();

// Eliminar una cookie estableciendo expires en el pasado
document.cookie = "ciudad=Valencia; expires=Thu, 01 Jan 1970 00:00:00 GMT";

// Explicación de max-age
document.cookie = "nombre=Pepe; max-age=3600"; // Expira en 1 hora
document.cookie = "nombre=Pepe; max-age=0"; // Eliminar cookie inmediatamente
<br><br>// Almacenamiento local: persistente y basado en pares clave-valor

// 1. Almacenar datos
localStorage.setItem("nombre", "Juan Pérez");
localStorage.setItem("edad", 30);

// 2. Recuperar datos
let nombre = localStorage.getItem("nombre");
console.log(nombre); // Imprime: "Juan Pérez"
let edad = localStorage.getItem("edad");
console.log(edad); // Imprime: 30

// 3. Eliminar datos
localStorage.removeItem("nombre");
console.log(localStorage.getItem("nombre")); // Imprime: null
localStorage.removeItem("edad");
console.log(localStorage.getItem("edad")); // Imprime: null

// 4. Limpiar todo el almacenamiento local
localStorage.clear();
console.log(localStorage.getItem("nombre")); // Imprime: null
console.log(localStorage.getItem("edad")); // Imprime: null
<br><br><br><br>let miBoton = document.getElementById("miBoton");

// Evento con DOM
miBoton.onclick=saludar;
function saludar() {alert("Hola")}; // tradicional
miBoton.onclick=function() {alert("Hola")}; // función anónima
miBoton2.onclick=()=&gt;alert ("Hola...") // fatArrow

// Evento con Listener
miBoton.addEventListener("click", saludar); // añadir evento
miBoton.removeEventListener("click", saludar) // eliminar evento
<br><br>// Event se utiliza para manejar eventos
// event.type = indica el evento
// event.currentTarget = elemento que disparó el evento
// event.clientX || event.clientY = coordenadas del cursor en la ventana
let miBoton = document.getElementById("miBoton");
miBoton.onclick = function(event) {
    alert("Evento " + event.type + " en " + event.currentTarget);
    alert("Coordenadas: " + event.clientX + ":" + event.clientY);
};
<br><br>// cuando se cargue la página lanzamos X evento
// DOM
function saludar() {
    console.log("La página ha sido cargada usando window.onload.");
}
window.onload = saludar;

window.onload = function() { // función anonima
    console.log("La página ha sido cargada con una función anónima.");
};

window.onload = () =&gt; { // fatArrow
    console.log("La página ha sido cargada con una función arrow.");
};

// addEventListener
window.addEventListener("load", function() {
    console.log("La página ha sido cargada con addEventListener.");
});
<br><br>const myEvent = new CustomEvent('myCustomEvent', { // crear evento
    detail: { 
	    message: 'Hola desde el evento personalizado', 
	    data: 42 
	}
}); 
    
let miBoton = document.getElementById("miBoton"); // asocia a elemto HTML una variable
miBoton.addEventListener("click", () =&gt; window.dispatchEvent(myEvent)); // lanzamos evento
window.addEventListener('myCustomEvent', (event) =&gt; {
    console.log(event.detail.message); // "Hola desde el evento personalizado"
});
<br><br><br><br>// ********************************************************************************
// Encontrar elementos HTML

document.getElementById("id");             // Encuentra un elemento por su ID
document.getElementsByTagName("name");     // Encuentra elementos por etiqueta HTML
document.getElementsByClassName("name");   // Encuentra elementos por clase CSS
document.querySelector("css");             // Selecciona el primer elemento que coincida con el selector CSS
document.querySelectorAll("css");          // Selecciona todos los elementos que coincidan con el selector CSS

// ********************************************************************************
// Cambiar elementos HTML

// Propiedades
element.innerHTML = "nuevo contenido";     // Cambia el contenido HTML de un elemento
element.attribute = "nuevo valor";         // Cambia el valor de un atributo de un elemento HTML
element.style.property = "nuevo estilo";   // Cambia el estilo de un elemento HTML

// Métodos
element.setAttribute("attribute", "value"); // Cambia el valor de un atributo de un elemento HTML
// Nota: `setAttribute` es un método que requiere el nombre y valor del atributo como argumentos.

// ********************************************************************************
// Añadir y eliminar elementos

document.createElement("element");         // Crea un nuevo elemento HTML
document.removeChild(element);             // Elimina un elemento HTML
document.appendChild(element);             // Añade un elemento HTML como hijo de otro
document.replaceChild(newElement, oldElement); // Reemplaza un elemento HTML por otro
document.write("texto");                   // Escribe texto o HTML directamente en la página

// ********************************************************************************
// Agregar controladores de eventos

document.getElementById("id").onclick = function() {
  // Código para gestionar el evento `onclick` del elemento con el ID especificado
};

// ********************************************************************************
// Encontrar objetos HTML

// HTML DOM Nivel 1 (1998) define 11 objetos HTML que siguen válidos en HTML5
document.anchors;      // Anclas en el documento
document.body;         // Cuerpo del documento
document.cookie;       // Cookies del documento
document.doctype;      // Tipo de documento
document.forms;        // Formularios en el documento
document.images;       // Imágenes en el documento
document.links;        // Enlaces en el documento
document.readyState;   // Estado de carga del documento
<br><br><br>// Propiedad `nodeName`: especifica el nombre de un nodo.
let elemento = document.getElementById("h1");
alert(elemento.nodeName); // Muestra "H1"

// - `nodeName` es de solo lectura.
// - Para un nodo de elemento, `nodeName` es el nombre de la etiqueta en MAYÚSCULAS.
// - Para un nodo de atributo, `nodeName` es el nombre del atributo.
// - Para un nodo de texto, `nodeName` siempre es "#text".
// - Para el nodo de documento, `nodeName` siempre es "#document".

// ********************************************************************************
// Propiedad `nodeValue`: especifica el valor de un nodo.
console.log(elemento.nodeValue);          // `null` para nodos de elemento
console.log(elemento.firstChild.nodeValue); // Texto de un nodo de texto

// - Para elementos de nodo, `nodeValue` es `null`.
// - Para nodos de texto, `nodeValue` es el texto en sí.
// - Para nodos de atributo, `nodeValue` es el valor del atributo.

// ********************************************************************************
// Propiedad `nodeType`: devuelve el tipo de un nodo. Es de solo lectura.

console.log(elemento.nodeType); // Devuelve 1 para ELEMENT_NODE

// Tipos de nodos más comunes:
const nodeTypes = {
  ELEMENT_NODE: 1,       // &lt;h1 class="heading"&gt;Titulo&lt;/h1&gt;
  ATTRIBUTE_NODE: 2,     // class = "heading" (obsoleto)
  TEXT_NODE: 3,          // Texto de un elemento
  COMMENT_NODE: 8,       // &lt;!-- This is a comment --&gt;
  DOCUMENT_NODE: 9,      // El documento HTML mismo (padre de &lt;html&gt;)
  DOCUMENT_TYPE_NODE: 10 // &lt;!Doctype html&gt;
};
<br><br>// Propiedades para navegar entre nodos
let nodoEjemplo = document.getElementById("p1");

let nodoPadre = nodoEjemplo.parentNode;             // Nodo padre de un nodo
let nodoHijos = nodoEjemplo.childNodes;             // Colección de hijos de un nodo
let primerHijo = nodoEjemplo.firstChild;            // Primer hijo de un nodo
let ultimoHijo = nodoEjemplo.lastChild;             // Último hijo de un nodo
let siguienteHermano = nodoEjemplo.nextSibling;     // Siguiente nodo hermano
let anteriorHermano = nodoEjemplo.previousSibling;  // Anterior nodo hermano

// ********************************************************************************
// Nodos secundarios y valores de nodo
// Un nodo de elemento no contiene texto directamente, sino un nodo de texto con el valor.

&lt;p id="p1"&gt;Tutorial DOM&lt;/p&gt;;

let miP1 = document.getElementById("p1").innerHTML;           // "Tutorial DOM"
let miP2 = document.getElementById("p1").firstChild.nodeValue; // "Tutorial DOM"
let miP3 = document.getElementById("p1").childNodes[0].nodeValue; // "Tutorial DOM"

// Ejemplo: copiar el texto de un &lt;h1&gt; a un &lt;p&gt; en tres formas
&lt;h1 id="h1"&gt;Mi pagina&lt;/h1&gt;
&lt;p id="p1"&gt;&lt;/p&gt;

&lt;script&gt;

document.getElementById("p1").innerHTML = document.getElementById("h1").innerHTML;
document.getElementById("p1").innerHTML=document.getElementById("h1").firstChild.nodeValue;

document.getElementById("p1").innerHTML=document.getElementById("h1").childNodes[0].nodeValue;

&lt;/script&gt;

// Nota: `innerHTML` es un método rápido para acceder al contenido HTML, pero conocer otros métodos ayuda a entender la estructura de árbol y navegación del DOM.

// Para nodos de texto, también se puede acceder al contenido mediante `textContent`.
let textoNodo = document.getElementById("demo").textContent;
<br><br>let misImagenes= document.images // podemos acceder a todas las imagenes del documento
let misLinks= document.links // podemos acceder a todos las links del documento
let misForms=document.forms // podemos acceder a todos las formularios del documento 
<br><br>&lt;!-- ATRIBUTO --&gt;
&lt;img id="miImagen" src="imagen1.gif"&gt; 

&lt;script&gt; 
	document.getElementById("miImagen").src = "imagen2.jpg"; 
&lt;/script&gt;

&lt;!-- ESTILO --&gt;
&lt;p id="p1"&gt;Hola mundo!&lt;/p&gt; 

&lt;script&gt;
	document.getElementById("p1").style.color = "blue"; 
&lt;/script&gt;
<br><br><br>let imagen = document.createElement("img");  // Crear nodo &lt;img&gt;
imagen.id = "mi_foto";  // Asignar id
imagen.src = "./fotos/logo.jpg";  // Asignar src para definir la imagen

// Añadir imagen al contenedor 'fotos'
let divFotos = document.getElementById("fotos");
divFotos.appendChild(imagen);  // Insertar nodo en el DOM

// Ejemplo con nodo de texto
let miParrafo = document.createElement("p");  // Crear nodo &lt;p&gt;
let miTexto = document.createTextNode("Texto del parrafo.");  // Crear nodo de texto
miParrafo.appendChild(miTexto);  // Agregar texto al &lt;p&gt;

// Añadir párrafo al contenedor 'div1'
let padre = document.getElementById("div1");
padre.appendChild(miParrafo);  // Insertar nodo en el DOM

// textContent para acceder o cambiar texto sin crear nodo de texto
const parrafo = document.getElementById("miParrafo");
console.log(parrafo.textContent);  // Obtener contenido de texto
parrafo.textContent = "Nuevo contenido para el párrafo.";  // Cambiar contenido

// insertBefore para añadir en una posición específica
let miparrafo = document.createElement("p");
let miTexto2 = document.createTextNode("Parrafo nuevo");
miparrafo.appendChild(miTexto2);
let elementoHijo = document.getElementById("p1");  // Nodo de referencia
padre.insertBefore(miparrafo, elementoHijo);  // Insertar antes de elementoHijo
<br><br>let parrafoEliminar = document.getElementById("p1");
parrafoEliminar.remove();  // Eliminar nodo directamente
<br><br>let nuevoParrafo = document.createElement("p");
let nodoTexto = document.createTextNode("Parrafo nuevo");
nuevoParrafo.appendChild(nodoTexto);
let child = document.getElementById("p1");  // Nodo a reemplazar
padre.replaceChild(nuevoParrafo, child);  // Reemplazar nodo
<br><br>// Método cloneNode(deep): deep = true copia el nodo y todos los descendientes
let clon = document.getElementById("miParrafo").cloneNode(true);
<br><br>// Asignación de evento onclick a un botón existente para mostrar la hora actual
document.getElementById("btn1").onclick = displayDate;

function displayDate() {
    document.getElementById("p1").innerHTML = Date();  // Muestra la fecha y hora actuales en el párrafo
}

// Crear un nuevo botón y asignarle un evento onclick usando una función anónima
let miBoton = document.createElement("button");        // Crear nodo &lt;button&gt;
miBoton.innerHTML = "Púlsame...";                      // Asignar texto al botón

miBoton.onclick = function() {                         // Asignar función anónima al evento onclick
    alert(this.innerHTML);                             // Muestra el texto del botón en un alert
};

document.body.appendChild(miBoton);                    // Añadir el botón al body
<br><br><br><br>const nombreInput = document.getElementById('nombre');
const emailInput = document.querySelector('input[name="correo"]');
const formulario = document.forms['registro'];
const botonEnviar = formulario.elements['enviar'];
<br><br>// 1. Evento 'change': Se dispara cuando cambia el valor de un campo
// En este caso, comprobamos el valor escrito en el campo 'nombre'
const nombreInput = document.getElementById('nombre');
nombreInput.addEventListener('change', function() {
    const nombre = nombreInput.value;
    console.log('El nombre ha cambiado a:', nombre);
});

// 2. Evento 'focus' y 'blur': Enfoque y desenfoque de un campo
// Podemos mostrar mensajes cuando el campo recibe o pierde el foco
nombreInput.addEventListener('focus', function() {
    console.log('El campo de nombre ha recibido el foco');
});

nombreInput.addEventListener('blur', function() {
    console.log('El campo de nombre ha perdido el foco');
});

// 3. Evento 'submit': Envío del formulario
// Se usa generalmente para validar y enviar datos
const formulario = document.getElementById('miFormulario');
formulario.addEventListener('submit', function(event) {
    event.preventDefault(); // Evita el envío del formulario por defecto
    // Validar los datos del formulario aquí
    if (nombreInput.value === '') {
        console.log('El campo de nombre está vacío');
        return; // Detener el proceso si el campo está vacío
    }
    // Si los datos son válidos, se podría enviar el formulario aquí
    console.log('Formulario enviado con éxito');
});
<br><br>// Manejador de evento submit para validación previa
formulario.addEventListener('submit', function(event) {
    event.preventDefault(); // Evita el envío por defecto
    // Validación de los datos
    if (nombreInput.value === '') {
        console.log('Por favor, complete el campo de nombre');
    } else {
        console.log('Datos del formulario válidos, listos para enviar');
    }
});
<br><br>// Función para validar un correo electrónico usando una expresión regular
function validarEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; // Patrón de regex básico para correos
    return regex.test(email); // Devuelve true si el email es válido
}

// Evento para validar el correo al perder el foco en el campo de email
const emailInput = document.getElementById('email');
emailInput.addEventListener('blur', function() {
    const email = emailInput.value;
    if (!validarEmail(email)) {
        alert('El correo electrónico no es válido.');
    }
});
<br>// Validación del campo Nombre y Email
function validarFormulario() {
    let errores = false;
    
    // Validación del nombre
    const nombreInput = document.getElementById('nombre');
    const nombreError = document.getElementById('nombreError');
    if (nombreInput.value === '' || nombreInput.value.length &lt; 5) {
        nombreError.style.display = 'block';
        nombreError.textContent = 'El nombre debe tener al menos 5 caracteres';
        errores = true;
    } else {
        nombreError.style.display = 'none';
    }

    // Validación del correo electrónico
    const emailInput = document.getElementById('email');
    const emailError = document.getElementById('emailError');
    if (emailInput.value === '' || !validarEmail(emailInput.value)) {
        emailError.style.display = 'block';
        emailError.textContent = 'Ingrese un correo electrónico válido';
        errores = true;
    } else {
        emailError.style.display = 'none';
    }

    // Si no hay errores, mostrar un mensaje de éxito
    if (!errores) {
        alert('Los datos se han enviado con éxito.');
    }
    return !errores; // Devuelve false si hay errores para evitar el envío
}

// Manejador del evento 'submit' del formulario
let formulario = document.getElementById('miFormulario');
formulario.addEventListener('submit', function(event) {
    event.preventDefault(); // Evita el envío del formulario si hay errores
    validarFormulario();
    //formulario.submit();
});
<br><br><br>// Obtener valores de un input y un textarea
const valorText = document.getElementById("texto").value;
const valorTextArea = document.getElementById("parrafo").value;
<br><br>// Obtener el estado de selección de cada radio button
let elementos = document.getElementsByName("estadoCivil");
Array.from(elementos).forEach(ec =&gt; console.log(`${ec.value} es ${ec.checked ? 'seleccionado' : 'no seleccionado'}`));
<br><br>// Verificar la selección de checkboxes
function verCondicionesPrivacidad() {
    const condiciones = document.getElementById("condiciones").checked ? " se ha aceptado" : " no se ha aceptado";
    
    const privacidad = document.getElementById("privacidad").checked ? " se ha aceptado" : " no se ha aceptado";
    
    console.log(`Condiciones: ${condiciones}, Privacidad: ${privacidad}`);
}
<br><br>// Obtener el valor seleccionado de un select
let lista = document.getElementById("lista");
console.log("Valor seleccionado:", lista.value);

lista.addEventListener("change", () =&gt; console.log("Nuevo valor:", lista.value));

// Acceder a una opción específica del select
let indiceSeleccionado = lista.selectedIndex;
let opcionSeleccionada = lista.options[indiceSeleccionado];
console.log("Texto seleccionado:", opcionSeleccionada.text);
console.log("Valor seleccionado:", opcionSeleccionada.value);
<br><br>// Añadir una opción a la lista
function anyadirElementoLista() {
    let texto = prompt("Dime Texto");
    let valor = prompt("Dime Valor");
    let mioption = document.createElement("option");
    mioption.value = valor;
    mioption.text = texto;
    lista.appendChild(mioption);
}

// Eliminar una opción de la lista
function eliminarElementoLista(indice) {
    if (lista.options.length &gt; 0) {
        lista.remove(indice);
    }
}
<br><br>// Ejemplo de manipulación de controles en formulario
document.getElementById("submitBtn").addEventListener("click", function(event) {
    event.preventDefault();

    // Cuadro de texto y textarea
    let nombre = document.getElementById("nombre").value;
    let mensaje = document.getElementById("mensaje").value;
    console.log("Nombre:", nombre, "Mensaje:", mensaje);

    // Radio Button
    let estadoCivilSeleccionado = Array.from(document.getElementsByName("estadoCivil"))
        .find(rb =&gt; rb.checked);
    console.log("Estado Civil Seleccionado:", estadoCivilSeleccionado ? estadoCivilSeleccionado.value : "Ninguno");

    // Checkbox
    let aceptaCondiciones = document.getElementById("condiciones").checked;
    console.log("Acepta Condiciones:", aceptaCondiciones);

    // Select
    let lista = document.getElementById("lista");
    let valorSeleccionado = lista.value;
    console.log("Valor Seleccionado de Lista:", valorSeleccionado);
});
<br><br><br>npm install -g json-server ## instalar
json-server --watch db.json ## inicializar API en -&gt; http://localhost:3000
<br><br><br>// Básico: GET con .then() y .catch()
fetch('https://api.example.com/entidades')
  .then(response =&gt; response.json())
  .then(data =&gt; console.log(data))
  .catch(error =&gt; console.error('Error:', error));

// DELETE
fetch('https://api.example.com/entidades/1', { method: 'DELETE' })
  .then(response =&gt; {
    if (response.ok) console.log('Elemento eliminado');
    else console.error('Error al eliminar');
  })
  .catch(error =&gt; console.error('Error:', error));

// POST (Enviar datos al servidor)
fetch('https://api.example.com/entidades', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ nombre: 'Nueva Entidad', activo: true }),
})
  .then(response =&gt; response.json())
  .then(data =&gt; console.log('Creado:', data))
  .catch(error =&gt; console.error('Error:', error));

// PUT (Actualizar datos completos)
fetch('https://api.example.com/entidades/1', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ nombre: 'Entidad Actualizada', activo: false }),
})
  .then(response =&gt; response.json())
  .then(data =&gt; console.log('Actualizado:', data))
  .catch(error =&gt; console.error('Error:', error));

// PATCH (Actualizar parcialmente)
fetch('https://api.example.com/entidades/1', {
  method: 'PATCH',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ activo: true }),
})
  .then(response =&gt; response.json())
  .then(data =&gt; console.log('Parcialmente Actualizado:', data))
  .catch(error =&gt; console.error('Error:', error));

// Encadenamiento de promesas + Refactorización
function manejarRespuesta(response) {
  if (!response.ok) throw new Error('Error en la respuesta');
  return response.json();
}

fetch('https://api.example.com/entidades')
  .then(manejarRespuesta)
  .then(data =&gt; {
    console.log('Primera respuesta:', data);
    return fetch(`https://api.example.com/entidades/${data[0].id}`);
  })
  .then(manejarRespuesta)
  .then(data =&gt; console.log('Segunda respuesta:', data))
  .catch(error =&gt; console.error('Error:', error));

// Función Genérica para GET
function getEntidad(url) {
  return fetch(url)
    .then(response =&gt; {
      if (!response.ok) throw new Error('Error al obtener entidad');
      return response.json();
    });
}

// Uso de getEntidad
getEntidad('https://api.example.com/entidades')
  .then(data =&gt; console.log(data))
  .catch(error =&gt; console.error('Error:', error));

// Async / Await
async function fetchConAsync() {
  try {
    const response = await fetch('https://api.example.com/entidades');
    if (!response.ok) throw new Error('Error al obtener datos');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}

// Ejemplo: Petición Encadenada para Datos de Artículo de Proveedor
async function obtenerArticuloProveedor(proveedorId) {
  try {
    const proveedor = await getEntidad(`https://api.example.com/proveedores/${proveedorId}`);
    const articulo = await getEntidad(`https://api.example.com/articulos/${proveedor.articuloId}`);
    console.log('Proveedor:', proveedor);
    console.log('Artículo:', articulo);
  } catch (error) {
    console.error('Error:', error);
  }
}
<br>]]></description><link>js-cheatsheet.html</link><guid isPermaLink="false">JS CheatSheet.md</guid><pubDate>Fri, 15 Nov 2024 08:49:26 GMT</pubDate></item></channel></rss>